================================================================================
UMKM MULTI-TENANT - SERVER SOURCE CODE COLLECTION
================================================================================
Generated on: $(date)

Project: UMKM Multi-Tenant Server
Location: /d/PRODUK-LPPM-FINAL/UMKM-MULTI-TENANT/server

================================================================================


================================================================================
FILE: .env.example
================================================================================


# Database (Supabase - NEW)
DATABASE_URL=
DIRECT_URL=

# JWT
JWT_SECRET=
JWT_EXPIRES_IN=

# App
NODE_ENV="development"
PORT=8000

# CORS
FRONTEND_URL="http://localhost:3000"
ALLOWED_ORIGINS="http://localhost:3000"

# Redis (Upstash - NEW)
UPSTASH_REDIS_REST_URL=
UPSTASH_REDIS_REST_TOKEN=

# ==========================================
# SEO ENGINE CONFIGURATION
# Add these variables to your .env file
# ==========================================

# ==========================================
# INDEXNOW API KEY
# Get from: https://www.bing.com/indexnow/getstarted
# Or generate any 8-32 character alphanumeric string
# ==========================================
INDEXNOW_API_KEY=your-indexnow-key-here

# ==========================================
# GOOGLE INDEXING API KEYS
# Multiple keys for rotation (200 requests/day each)
# Format: JSON array of service account credentials
#
# How to get:
# 1. Create Google Cloud project
# 2. Enable "Web Search Indexing API"
# 3. Create Service Account
# 4. Download JSON key
# 5. Add service account to Google Search Console as Owner
# 6. Repeat for each key
# ==========================================

# Single key example:
GOOGLE_INDEXING_KEYS='[{"projectId":"fibidy-seo-1","clientEmail":"seo@fibidy-seo-1.iam.gserviceaccount.com","privateKey":"-----BEGIN PRIVATE KEY-----\nYOUR_KEY_HERE\n-----END PRIVATE KEY-----\n"}]'

# Multiple keys example (5 keys = 1000 requests/day):
# GOOGLE_INDEXING_KEYS='[
#   {"projectId":"fibidy-seo-1","clientEmail":"seo@fibidy-seo-1.iam.gserviceaccount.com","privateKey":"..."},
#   {"projectId":"fibidy-seo-2","clientEmail":"seo@fibidy-seo-2.iam.gserviceaccount.com","privateKey":"..."},
#   {"projectId":"fibidy-seo-3","clientEmail":"seo@fibidy-seo-3.iam.gserviceaccount.com","privateKey":"..."},
#   {"projectId":"fibidy-seo-4","clientEmail":"seo@fibidy-seo-4.iam.gserviceaccount.com","privateKey":"..."},
#   {"projectId":"fibidy-seo-5","clientEmail":"seo@fibidy-seo-5.iam.gserviceaccount.com","privateKey":"..."}
# ]'

# ==========================================
# NOTES:
# - Start with 1 key, add more as needed
# - Each key = 200 URLs/day
# - 5 keys = 1000 URLs/day (enough for 200 new tenants/day)
# - Private key must have \n replaced with actual newlines or escaped as \\n
# ==========================================



================================================================================
FILE: .prettierrc
================================================================================

{
  "singleQuote": true,
  "trailingComma": "all"
}



================================================================================
FILE: nest-cli.json
================================================================================

{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}



================================================================================
FILE: package.json
================================================================================

{
  "name": "server",
  "version": "0.0.1",
  "description": "UMKM Multi-Tenant Backend API",
  "author": "Fibidy",
  "private": true,
  "license": "MIT",
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "start:migrate": "prisma migrate deploy && prisma db seed && node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json",
    "prisma:generate": "prisma generate",
    "prisma:migrate": "prisma migrate dev",
    "prisma:studio": "prisma studio",
    "prisma:seed": "ts-node prisma/seed.ts",
    "prisma:reset": "prisma migrate reset --skip-seed && npm run prisma:seed"
  },
  "dependencies": {
    "@nestjs/axios": "^4.0.1",
    "@nestjs/common": "^11.0.1",
    "@nestjs/config": "^4.0.2",
    "@nestjs/core": "^11.0.1",
    "@nestjs/jwt": "^11.0.2",
    "@nestjs/mapped-types": "^2.1.0",
    "@nestjs/passport": "^11.0.5",
    "@nestjs/platform-express": "^11.0.1",
    "@nestjs/throttler": "^6.5.0",
    "@prisma/client": "6.0.1",
    "@types/compression": "^1.8.1",
    "@upstash/redis": "^1.36.0",
    "ajv": "^8.17.1",
    "ajv-formats": "^3.0.1",
    "axios": "^1.13.2",
    "bcrypt": "^6.0.0",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.3",
    "compression": "^1.8.1",
    "cookie-parser": "^1.4.7",
    "googleapis": "^168.0.0",
    "passport": "^0.7.0",
    "passport-jwt": "^4.0.1",
    "reflect-metadata": "^0.2.2",
    "rxjs": "^7.8.1"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3.2.0",
    "@eslint/js": "^9.18.0",
    "@nestjs/cli": "^11.0.0",
    "@nestjs/schematics": "^11.0.0",
    "@nestjs/testing": "^11.0.1",
    "@types/ajv": "^1.0.4",
    "@types/bcrypt": "^6.0.0",
    "@types/cookie-parser": "^1.4.10",
    "@types/express": "^5.0.0",
    "@types/jest": "^30.0.0",
    "@types/node": "^22.10.7",
    "@types/passport-jwt": "^4.0.1",
    "@types/supertest": "^6.0.2",
    "eslint": "^9.18.0",
    "eslint-config-prettier": "^10.0.1",
    "eslint-plugin-prettier": "^5.2.2",
    "globals": "^16.0.0",
    "jest": "^30.0.0",
    "prettier": "^3.4.2",
    "prisma": "6.0.1",
    "source-map-support": "^0.5.21",
    "supertest": "^7.0.0",
    "ts-jest": "^29.2.5",
    "ts-loader": "^9.5.2",
    "ts-node": "^10.9.2",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.7.3",
    "typescript-eslint": "^8.20.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  },
  "prisma": {
    "seed": "ts-node prisma/seed.ts"
  },
  "engines": {
    "node": ">=18.0.0",
    "npm": ">=9.0.0"
  }
}



================================================================================
FILE: tsconfig.json
================================================================================

{
  "compilerOptions": {
    "module": "nodenext",
    "moduleResolution": "nodenext",
    "resolvePackageJsonExports": true,
    "esModuleInterop": true,
    "isolatedModules": true,
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2023",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": true,
    "forceConsistentCasingInFileNames": true,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "noFallthroughCasesInSwitch": false
  }
}



================================================================================
FILE: tsconfig.build.json
================================================================================

{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}



================================================================================
FILE: README.md
================================================================================

# Fibidy Backend API

Backend API untuk platform multi-tenant UMKM Fibidy - memungkinkan UMKM membuat toko online dengan mudah.

## ðŸš€ Quick Start

### Install Dependencies
```bash
npm install
```

### Setup Database
```bash
# Generate Prisma Client
npm run prisma:generate

# Build aplikasi
npm run build

# Run migrations + seed + start
npm run start:migrate
```

## ðŸ› ï¸ Development

```bash
# Development mode
npm run start:dev

# Production mode
npm run start:prod
```

## ðŸ“¦ Database Commands

```bash
# Generate Prisma Client
npm run prisma:generate

# Run migrations (dev)
npm run prisma:migrate

# Seed database
npm run prisma:seed

# Open Prisma Studio
npm run prisma:studio

# Reset database
npm run prisma:reset
```

## ðŸ”‘ Environment Variables

Buat file `.env`:

```env
# Database
DATABASE_URL="postgresql://user:password@host:6543/db?pgbouncer=true"
DIRECT_URL="postgresql://user:password@host:5432/db"

# JWT
JWT_SECRET="your-secret-key"
JWT_EXPIRES_IN="7d"

# App
NODE_ENV="production"
PORT=8000

# CORS
FRONTEND_URL="https://www.fibidy.com"
ALLOWED_ORIGINS="https://www.fibidy.com"

# Redis
UPSTASH_REDIS_REST_URL="https://..."
UPSTASH_REDIS_REST_TOKEN="..."
```

## ðŸ“š Tech Stack

- **Framework**: NestJS
- **Database**: PostgreSQL (Supabase)
- **ORM**: Prisma
- **Cache**: Upstash Redis
- **Auth**: JWT + Passport

## ðŸ—ï¸ Project Structure

```
src/
â”œâ”€â”€ auth/           # Authentication module
â”œâ”€â”€ tenants/        # Tenant management
â”œâ”€â”€ products/       # Product management
â”œâ”€â”€ orders/         # Order management
â”œâ”€â”€ customers/      # Customer management
â””â”€â”€ common/         # Shared utilities
```

## ðŸ“„ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## ðŸ“§ Contact

- Website: https://www.fibidy.com
- Email: support@fibidy.com



================================================================================
FILE: .gitignore
================================================================================

# File: UMKM-MULTI-TENANT/.gitignore

# Dependencies
node_modules
.pnpm-store
pnpm-lock.yaml

# Build outputs
dist
.next
out
build

# Environment files
.env
.env.local
.env.*.local

# IDE
.vscode
.idea
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Logs
*.log
npm-debug.log*
pnpm-debug.log*

# Prisma
server/prisma/*.db
server/prisma/*.db-journal

# Misc
*.tsbuildinfo
/generated/prisma

# Docker (Local Development Only)
docker-compose.yml
docker-compose.*.yml
Dockerfile
Dockerfile.*
.dockerignore



================================================================================
FILE: prisma/schema.prisma
================================================================================

// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ==========================================
// ENUMS
// ==========================================

enum TenantStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
}

enum OrderStatus {
  PENDING
  PROCESSING
  COMPLETED
  CANCELLED
}

enum PaymentStatus {
  PENDING
  PAID
  PARTIAL
  FAILED
}

// ==========================================
// TENANT (UMKM)
// ==========================================

model Tenant {
  id            String       @id @default(cuid())
  slug          String       @unique
  name          String
  category      String
  description   String?
  whatsapp      String
  email         String       @unique
  phone         String?
  address       String?
  logo          String?
  banner        String?
  theme         Json?
  landingConfig Json?
  
  // ==========================================
  // SEO FIELDS
  // ==========================================
  metaTitle       String?   @db.VarChar(60)
  metaDescription String?   @db.VarChar(160)
  socialLinks     Json?     // { instagram, facebook, tiktok, youtube, twitter }
  
  // ==========================================
  // PAYMENT SETTINGS (NEW)
  // ==========================================
  currency        String    @default("IDR")
  taxRate         Float     @default(0)        // Percentage, e.g., 11 for 11%
  paymentMethods  Json?     // See PaymentMethods type below
  
  // ==========================================
  // SHIPPING SETTINGS (NEW)
  // ==========================================
  freeShippingThreshold  Float?                // Minimum order for free shipping
  defaultShippingCost    Float     @default(0) // Default shipping cost
  shippingMethods        Json?                 // See ShippingMethods type below
  
  password      String
  status        TenantStatus @default(ACTIVE)
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt

  products      Product[]
  customers     Customer[]
  orders        Order[]

  @@index([slug])
  @@index([category])
  @@index([status])
}

// ==========================================
// PRODUCT / SERVICE
// ==========================================

model Product {
  id           String   @id @default(cuid())
  tenantId     String
  tenant       Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  
  // Basic Info
  name         String
  description  String?
  category     String?
  sku          String?
  
  // Pricing
  price        Float
  comparePrice Float?
  costPrice    Float?
  
  // Stock
  stock        Int?
  minStock     Int?
  trackStock   Boolean  @default(false)
  unit         String?
  
  // Media
  images       String[]
  
  // Category-specific data
  metadata     Json?
  
  // Status
  isActive     Boolean  @default(true)
  isFeatured   Boolean  @default(false)
  
  // ==========================================
  // SEO SLUG (Already exists - just adding constraints)
  // ==========================================
  slug         String?
  
  // Timestamps
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  // Relations
  orderItems   OrderItem[]
  
  @@unique([tenantId, sku])
  @@unique([tenantId, slug])  // NEW: Ensure unique slug per tenant
  @@index([tenantId])
  @@index([tenantId, isActive])
  @@index([tenantId, category])
  @@index([tenantId, isFeatured])
  @@index([tenantId, slug])   // NEW: Index for slug lookups
}

// ==========================================
// CUSTOMER
// ==========================================

model Customer {
  id          String   @id @default(cuid())
  tenantId    String
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  
  // Basic Info
  name        String
  phone       String
  email       String?
  address     String?
  
  // Category-specific data
  metadata    Json?
  
  // Stats
  totalOrders Int      @default(0)
  totalSpent  Float    @default(0)
  
  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  orders      Order[]
  
  @@unique([tenantId, phone])
  @@index([tenantId])
  @@index([tenantId, phone])
  @@index([tenantId, name])
}

// ==========================================
// ORDER / TRANSACTION
// ==========================================

model Order {
  id            String        @id @default(cuid())
  tenantId      String
  tenant        Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  
  customerId    String?
  customer      Customer?     @relation(fields: [customerId], references: [id], onDelete: SetNull)
  
  // Order Info
  orderNumber   String
  
  // Items
  items         OrderItem[]
  
  // Pricing
  subtotal      Float
  discount      Float         @default(0)
  tax           Float         @default(0)
  total         Float
  
  // Payment
  paymentMethod String?
  paymentStatus PaymentStatus @default(PENDING)
  paidAmount    Float         @default(0)
  
  // Status
  status        OrderStatus   @default(PENDING)
  
  // Guest Order
  customerName  String?
  customerPhone String?
  
  // Notes
  notes         String?
  
  // Category-specific data
  metadata      Json?
  
  // Timestamps
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  completedAt   DateTime?
  
  @@unique([tenantId, orderNumber])
  @@index([tenantId])
  @@index([tenantId, status])
  @@index([tenantId, paymentStatus])
  @@index([tenantId, createdAt])
  @@index([customerId])
  @@index([tenantId, paymentStatus, createdAt])
}

// ==========================================
// ORDER ITEM
// ==========================================

model OrderItem {
  id        String   @id @default(cuid())
  orderId   String
  order     Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  
  productId String?
  product   Product? @relation(fields: [productId], references: [id], onDelete: SetNull)
  
  // Store info (in case product deleted/changed)
  name      String
  price     Float
  qty       Int
  subtotal  Float
  
  // Additional
  notes     String?
  metadata  Json?
  
  @@index([orderId])
  @@index([productId])
}



================================================================================
FILE: src/main.ts
================================================================================

import { NestFactory } from '@nestjs/core';
import { ValidationPipe, Logger } from '@nestjs/common';
import { AppModule } from './app.module';
import cookieParser from 'cookie-parser';
import compression from 'compression';

// Import custom pipes, filters, interceptors
import { SanitizePipe } from './common/pipes/sanitize.pipe';
import { AllExceptionsFilter } from './common/filters/all-exceptions.filter';
import { LoggingInterceptor } from './common/interceptors/logging.interceptor';

async function bootstrap() {
  const logger = new Logger('Bootstrap');

  const app = await NestFactory.create(AppModule, {
    logger: ['error', 'warn', 'log'],
  });

  // ==========================================
  // ðŸ”¥ NEW: Compression middleware (gzip)
  // ==========================================
  app.use(compression());

  // Cookie Parser
  app.use(cookieParser());

  // Allowed origins from ENV
  const allowedOrigins = (process.env.FRONTEND_URL || 'http://localhost:3000')
    .split(',')
    .map((origin) => origin.trim());

  // CORS with dynamic origin validation
  app.enableCors({
    origin: (
      origin: string | undefined,
      callback: (err: Error | null, allow?: boolean) => void,
    ) => {
      if (!origin) return callback(null, true);
      if (allowedOrigins.includes(origin)) {
        callback(null, true);
      } else {
        callback(new Error('Not allowed by CORS'));
      }
    },
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'],
    allowedHeaders: [
      'Content-Type',
      'Authorization',
      'Cookie',
      'Cache-Control',
      'Pragma',
      'Expires',
    ],
    exposedHeaders: ['Set-Cookie'],
  });

  // Global prefix
  app.setGlobalPrefix('api');

  // ==========================================
  // ðŸ”¥ NEW: Global Exception Filter
  // ==========================================
  app.useGlobalFilters(new AllExceptionsFilter());

  // ==========================================
  // ðŸ”¥ NEW: Global Logging Interceptor
  // ==========================================
  app.useGlobalInterceptors(new LoggingInterceptor());

  // ==========================================
  // ðŸ”¥ UPDATED: Add SanitizePipe before ValidationPipe
  // ==========================================
  app.useGlobalPipes(
    new SanitizePipe(),
    new ValidationPipe({
      whitelist: true,
      forbidNonWhitelisted: false,
      transform: true,
      transformOptions: {
        enableImplicitConversion: true,
      },
    }),
  );

  // Enable graceful shutdown
  app.enableShutdownHooks();

  // ==========================================
  // ðŸ”¥ FIXED: Graceful shutdown handlers
  // Use void to explicitly ignore the promise
  // ==========================================
  process.on('SIGTERM', () => {
    logger.log('SIGTERM received, shutting down gracefully...');
    void app.close().then(() => {
      process.exit(0);
    });
  });

  process.on('SIGINT', () => {
    logger.log('SIGINT received, shutting down gracefully...');
    void app.close().then(() => {
      process.exit(0);
    });
  });

  const port = process.env.PORT || 8000;
  await app.listen(port, '0.0.0.0');

  logger.log(`ðŸš€ Server running on http://localhost:${port}`);
  logger.log(`ðŸ“š API endpoint: http://localhost:${port}/api`);
  logger.log(`ðŸŒ CORS enabled for: ${allowedOrigins.join(', ')}`);
  logger.log(`ðŸ—œï¸ Compression: enabled`);
  logger.log(`ðŸ›¡ï¸ XSS Protection: enabled`);
}

bootstrap().catch((error) => {
  console.error('âŒ Failed to start:', error);
  process.exit(1);
});



================================================================================
FILE: src/app.module.ts
================================================================================

import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { ThrottlerModule, ThrottlerGuard } from '@nestjs/throttler';
import { APP_GUARD } from '@nestjs/core';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { PrismaModule } from './prisma/prisma.module';
import { RedisModule } from './redis/redis.module';
import { AuthModule } from './auth/auth.module';
import { TenantsModule } from './tenants/tenants.module';
import { ProductsModule } from './products/products.module';
import { CustomersModule } from './customers/customers.module';
import { OrdersModule } from './orders/orders.module';
import { SitemapModule } from './sitemap/sitemap.module';
import { SeoModule } from './seo/seo.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
    }),
    // Rate Limiting - 100 requests per 60 seconds per IP
    ThrottlerModule.forRoot([
      {
        ttl: 60000, // 60 seconds in milliseconds
        limit: 100, // max 100 requests
      },
    ]),
    PrismaModule,
    RedisModule, // ðŸ”¥ Add Redis Module
    AuthModule,
    TenantsModule,
    ProductsModule,
    CustomersModule,
    OrdersModule,
    SitemapModule,
    SeoModule,
  ],
  controllers: [AppController],
  providers: [
    AppService,
    // Apply rate limiting globally
    {
      provide: APP_GUARD,
      useClass: ThrottlerGuard,
    },
  ],
})
export class AppModule {}



================================================================================
FILE: src/app.controller.ts
================================================================================

import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';
import { PrismaService } from './prisma/prisma.service';
import { RedisService } from './redis/redis.service';

@Controller()
export class AppController {
  constructor(
    private readonly appService: AppService,
    private readonly prisma: PrismaService,
    private readonly redis: RedisService,
  ) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }

  @Get('health')
  async healthCheck() {
    const checks: {
      status: string;
      timestamp: string;
      database: string;
      cache: { status: string; latency?: number };
      uptime: number;
    } = {
      status: 'ok',
      timestamp: new Date().toISOString(),
      database: 'unknown',
      cache: { status: 'unknown' },
      uptime: process.uptime(),
    };

    // Check database
    try {
      await this.prisma.$queryRaw`SELECT 1`;
      checks.database = 'connected';
    } catch {
      checks.database = 'disconnected';
      checks.status = 'degraded';
    }

    // Check Redis
    try {
      checks.cache = await this.redis.healthCheck();
      if (checks.cache.status === 'error') {
        checks.status = 'degraded';
      }
    } catch {
      checks.cache = { status: 'error' };
      checks.status = 'degraded';
    }

    return checks;
  }
}



================================================================================
FILE: src/app.service.ts
================================================================================

import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}



================================================================================
FILE: src/app.controller.spec.ts
================================================================================

import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});



================================================================================
FILE: src/auth/auth.module.ts
================================================================================

import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { JwtStrategy } from './strategies/jwt.strategy';
import { TenantsModule } from '../tenants/tenants.module';

@Module({
  imports: [
    PassportModule.register({ defaultStrategy: 'jwt' }),
    JwtModule.registerAsync({
      imports: [ConfigModule],
      useFactory: (configService: ConfigService) => {
        const secret = configService.get<string>('JWT_SECRET');
        const expiresIn = configService.get('JWT_EXPIRES_IN');

        if (!secret) {
          throw new Error('JWT_SECRET is not defined');
        }

        return {
          secret,
          signOptions: {
            expiresIn: expiresIn || '7d',
          },
        };
      },
      inject: [ConfigService],
    }),
    TenantsModule,
  ],
  controllers: [AuthController],
  providers: [AuthService, JwtStrategy],
  exports: [AuthService, JwtModule],
})
export class AuthModule {}



================================================================================
FILE: src/auth/auth.controller.ts
================================================================================

import {
  Controller,
  Post,
  Get,
  Body,
  Param,
  Res,
  Req,
  UseGuards,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import type { Response, Request } from 'express';
import { AuthService } from './auth.service';
import { RegisterDto, LoginDto } from './dto';
import { JwtAuthGuard } from '../common/guards/jwt-auth.guard';
import { CurrentTenant } from '../common/decorators/tenant.decorator';
import { TenantsService } from '../tenants/tenants.service';

// ==========================================
// COOKIE CONFIGURATION
// ==========================================

const COOKIE_NAME = 'fibidy_auth';
const COOKIE_OPTIONS = {
  httpOnly: true,
  secure: process.env.NODE_ENV === 'production',
  sameSite: 'lax' as const,
  path: '/',
  maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
};

@Controller('auth')
export class AuthController {
  constructor(
    private authService: AuthService,
    private tenantsService: TenantsService,
  ) {}

  // ==========================================
  // REGISTER
  // ==========================================
  @Post('register')
  @HttpCode(HttpStatus.CREATED)
  async register(
    @Body() dto: RegisterDto,
    @Res({ passthrough: true }) res: Response,
  ) {
    const result = await this.authService.register(dto);
    res.cookie(COOKIE_NAME, result.access_token, COOKIE_OPTIONS);

    return {
      message: 'Pendaftaran berhasil',
      tenant: result.tenant,
    };
  }

  // ==========================================
  // LOGIN
  // ==========================================
  @Post('login')
  @HttpCode(HttpStatus.OK)
  async login(
    @Body() dto: LoginDto,
    @Res({ passthrough: true }) res: Response,
  ) {
    const result = await this.authService.login(dto);
    res.cookie(COOKIE_NAME, result.access_token, COOKIE_OPTIONS);

    return {
      message: 'Login berhasil',
      tenant: result.tenant,
    };
  }

  // ==========================================
  // LOGOUT
  // ==========================================
  @Post('logout')
  @HttpCode(HttpStatus.OK)
  logout(@Res({ passthrough: true }) res: Response) {
    res.clearCookie(COOKIE_NAME, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax' as const,
      path: '/',
    });

    return { message: 'Logout berhasil' };
  }

  // ==========================================
  // GET ME
  // ==========================================
  @Get('me')
  @UseGuards(JwtAuthGuard)
  async me(@CurrentTenant() tenant: { id: string }) {
    return this.authService.me(tenant.id);
  }

  // ==========================================
  // REFRESH TOKEN
  // ==========================================
  @Post('refresh')
  @UseGuards(JwtAuthGuard)
  @HttpCode(HttpStatus.OK)
  async refresh(
    @CurrentTenant() tenant: { id: string },
    @Res({ passthrough: true }) res: Response,
  ) {
    const result = await this.authService.refresh(tenant.id);
    res.cookie(COOKIE_NAME, result.access_token, COOKIE_OPTIONS);

    return {
      message: 'Token refreshed',
      tenant: result.tenant,
    };
  }

  // ==========================================
  // CHECK AUTH STATUS
  // ==========================================
  @Get('status')
  async checkStatus(@Req() req: Request) {
    const cookies = req.cookies as Record<string, string> | undefined;
    const token = cookies?.[COOKIE_NAME];

    if (!token) {
      return { authenticated: false, tenant: null };
    }

    try {
      const tenant = await this.authService.verifyToken(token);
      return { authenticated: true, tenant };
    } catch {
      return { authenticated: false, tenant: null };
    }
  }

  // ==========================================
  // CHECK SLUG
  // ==========================================
  @Get('check-slug/:slug')
  async checkSlug(@Param('slug') slug: string) {
    return this.tenantsService.checkSlugAvailability(slug);
  }
}



================================================================================
FILE: src/auth/auth.service.ts
================================================================================

import {
  Injectable,
  UnauthorizedException,
  ConflictException,
  NotFoundException,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import * as bcrypt from 'bcrypt';
import { PrismaService } from '../prisma/prisma.service';
import { RedisService } from '../redis/redis.service';
import { SeoService } from '../seo/seo.service';
import { RegisterDto, LoginDto } from './dto';
import { getDefaultLandingConfig } from '../validators/landing-config.validator';
import type { Tenant, Prisma } from '@prisma/client'; // âœ… FIX: Import Prisma

const MAX_LOGIN_ATTEMPTS = 5;
const LOCKOUT_DURATION_SECONDS = 900;

@Injectable()
export class AuthService {
  constructor(
    private prisma: PrismaService,
    private jwtService: JwtService,
    private redis: RedisService,
    private seoService: SeoService,
  ) {}

  async register(dto: RegisterDto) {
    const existingEmail = await this.prisma.tenant.findUnique({
      where: { email: dto.email },
    });

    if (existingEmail) {
      throw new ConflictException('Email sudah terdaftar');
    }

    const existingSlug = await this.prisma.tenant.findUnique({
      where: { slug: dto.slug.toLowerCase() },
    });

    if (existingSlug) {
      throw new ConflictException('Slug sudah digunakan');
    }

    const hashedPassword = await bcrypt.hash(dto.password, 12);

    const tenant = await this.prisma.tenant.create({
      data: {
        slug: dto.slug.toLowerCase(),
        name: dto.name,
        category: dto.category,
        email: dto.email.toLowerCase(),
        password: hashedPassword,
        whatsapp: dto.whatsapp,
        description: dto.description,
        phone: dto.phone,
        address: dto.address,
        currency: 'IDR',
        taxRate: 0,
        paymentMethods: {
          bankAccounts: [],
          eWallets: [],
          cod: { enabled: false, note: '' },
        },
        freeShippingThreshold: null,
        defaultShippingCost: 0,
        shippingMethods: {
          couriers: [
            { id: 'jne', name: 'JNE', enabled: true, note: '' },
            { id: 'jt', name: 'J&T Express', enabled: true, note: '' },
            { id: 'sicepat', name: 'SiCepat', enabled: false, note: '' },
            { id: 'anteraja', name: 'AnterAja', enabled: false, note: '' },
            { id: 'ninja', name: 'Ninja Express', enabled: false, note: '' },
          ],
        },
        // âœ… FIX: Cast to Prisma.InputJsonValue
        landingConfig:
          getDefaultLandingConfig() as unknown as Prisma.InputJsonValue,
      },
    });

    this.seoService.onTenantCreated(tenant.slug).catch((error) => {
      console.error('[SEO] Failed to index new tenant:', error.message);
    });

    const token = this.generateToken(tenant);

    return {
      access_token: token,
      tenant: this.sanitizeTenant(tenant),
    };
  }

  async login(dto: LoginDto) {
    const email = dto.email.toLowerCase();

    const lockKey = `login:lockout:${email}`;
    const failKey = `login:fails:${email}`;

    const isLocked = await this.redis.get<string>(lockKey);
    if (isLocked) {
      throw new UnauthorizedException(
        'Akun terkunci karena terlalu banyak percobaan gagal. Coba lagi dalam 15 menit.',
      );
    }

    const tenant = await this.prisma.tenant.findUnique({
      where: { email },
    });

    if (!tenant) {
      await this.trackFailedLogin(email, failKey, lockKey);
      throw new UnauthorizedException('Email atau password salah');
    }

    const isPasswordValid = await bcrypt.compare(dto.password, tenant.password);

    if (!isPasswordValid) {
      await this.trackFailedLogin(email, failKey, lockKey);
      throw new UnauthorizedException('Email atau password salah');
    }

    if (tenant.status !== 'ACTIVE') {
      throw new UnauthorizedException('Akun tidak aktif');
    }

    await this.redis.del(failKey);

    const token = this.generateToken(tenant);

    return {
      access_token: token,
      tenant: this.sanitizeTenant(tenant),
    };
  }

  private async trackFailedLogin(
    email: string,
    failKey: string,
    lockKey: string,
  ): Promise<void> {
    const currentFails = await this.redis.get<number>(failKey);
    const failCount = (currentFails || 0) + 1;

    await this.redis.set(failKey, failCount, LOCKOUT_DURATION_SECONDS);

    if (failCount >= MAX_LOGIN_ATTEMPTS) {
      await this.redis.set(lockKey, 'locked', LOCKOUT_DURATION_SECONDS);
      console.warn(`[Security] Account locked due to failed logins: ${email}`);
    }
  }

  async me(tenantId: string) {
    const tenant = await this.prisma.tenant.findUnique({
      where: { id: tenantId },
      select: {
        id: true,
        slug: true,
        name: true,
        email: true,
        category: true,
        description: true,
        whatsapp: true,
        phone: true,
        address: true,
        logo: true,
        banner: true,
        theme: true,
        status: true,
        createdAt: true,
        updatedAt: true,
        _count: {
          select: {
            products: true,
            customers: true,
            orders: true,
          },
        },
      },
    });

    if (!tenant) {
      throw new NotFoundException('Tenant tidak ditemukan');
    }

    return tenant;
  }

  async refresh(tenantId: string) {
    const tenant = await this.prisma.tenant.findUnique({
      where: { id: tenantId },
    });

    if (!tenant) {
      throw new NotFoundException('Tenant tidak ditemukan');
    }

    const token = this.generateToken(tenant);

    return {
      access_token: token,
      tenant: this.sanitizeTenant(tenant),
    };
  }

  async verifyToken(token: string) {
    try {
      const payload = this.jwtService.verify(token);
      const tenant = await this.prisma.tenant.findUnique({
        where: { id: payload.sub },
        select: {
          id: true,
          slug: true,
          name: true,
          email: true,
          category: true,
          description: true,
          whatsapp: true,
          phone: true,
          address: true,
          logo: true,
          banner: true,
          theme: true,
          status: true,
          createdAt: true,
          updatedAt: true,
        },
      });

      if (!tenant) {
        throw new UnauthorizedException('Invalid token');
      }

      return tenant;
    } catch {
      throw new UnauthorizedException('Invalid token');
    }
  }

  private generateToken(tenant: Tenant): string {
    const payload = {
      sub: tenant.id,
      email: tenant.email,
      slug: tenant.slug,
    };

    return this.jwtService.sign(payload);
  }

  private sanitizeTenant(tenant: Tenant) {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { password: _, ...result } = tenant;
    return result;
  }
}



================================================================================
FILE: src/auth/dto/index.ts
================================================================================

export * from './register.dto';
export * from './login.dto';



================================================================================
FILE: src/auth/dto/login.dto.ts
================================================================================

import { IsEmail, IsNotEmpty, IsString } from 'class-validator';

export class LoginDto {
  @IsEmail({}, { message: 'Format email tidak valid' })
  @IsNotEmpty({ message: 'Email tidak boleh kosong' })
  email: string;

  @IsString()
  @IsNotEmpty({ message: 'Password tidak boleh kosong' })
  password: string;
}



================================================================================
FILE: src/auth/dto/register.dto.ts
================================================================================

import {
  IsEmail,
  IsNotEmpty,
  IsString,
  MinLength,
  MaxLength,
  Matches,
  IsOptional,
} from 'class-validator';

export class RegisterDto {
  @IsString()
  @IsNotEmpty({ message: 'Slug tidak boleh kosong' })
  @MinLength(3, { message: 'Slug minimal 3 karakter' })
  @MaxLength(30, { message: 'Slug maksimal 30 karakter' })
  @Matches(/^[a-z0-9]+(?:-[a-z0-9]+)*$/, {
    message: 'Slug hanya boleh huruf kecil, angka, dan strip (-)',
  })
  slug: string;

  @IsString()
  @IsNotEmpty({ message: 'Nama toko tidak boleh kosong' })
  @MinLength(3, { message: 'Nama toko minimal 3 karakter' })
  @MaxLength(100, { message: 'Nama toko maksimal 100 karakter' })
  name: string;

  @IsString()
  @IsNotEmpty({ message: 'Kategori tidak boleh kosong' })
  category: string;

  @IsEmail({}, { message: 'Format email tidak valid' })
  @IsNotEmpty({ message: 'Email tidak boleh kosong' })
  email: string;

  // ==========================================
  // ðŸ”¥ UPDATED: Stronger password policy
  // Min 8 chars, must have uppercase, lowercase, and number
  // ==========================================
  @IsString()
  @IsNotEmpty({ message: 'Password tidak boleh kosong' })
  @MinLength(8, { message: 'Password minimal 8 karakter' })
  @Matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/, {
    message: 'Password harus mengandung huruf besar, huruf kecil, dan angka',
  })
  password: string;

  @IsString()
  @IsNotEmpty({ message: 'Nomor WhatsApp tidak boleh kosong' })
  @Matches(/^62[0-9]{9,13}$/, {
    message: 'Format WhatsApp harus diawali 62 (contoh: 6281234567890)',
  })
  whatsapp: string;

  @IsOptional()
  @IsString()
  description?: string;

  @IsOptional()
  @IsString()
  phone?: string;

  @IsOptional()
  @IsString()
  address?: string;
}



================================================================================
FILE: src/auth/strategies/index.ts
================================================================================

export * from './jwt.strategy';



================================================================================
FILE: src/auth/strategies/jwt.strategy.ts
================================================================================

import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { ConfigService } from '@nestjs/config';
import type { Request } from 'express';
import { PrismaService } from '../../prisma/prisma.service';

const COOKIE_NAME = 'fibidy_auth';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(
    private configService: ConfigService,
    private prisma: PrismaService,
  ) {
    const secret = configService.get<string>('JWT_SECRET');

    if (!secret) {
      throw new Error('JWT_SECRET is not defined');
    }

    super({
      jwtFromRequest: ExtractJwt.fromExtractors([
        // 1. Try cookie first
        (request: Request) => {
          const cookies = request?.cookies as
            | Record<string, string>
            | undefined;
          return cookies?.[COOKIE_NAME] ?? null;
        },
        // 2. Fallback to Authorization header
        ExtractJwt.fromAuthHeaderAsBearerToken(),
      ]),
      ignoreExpiration: false,
      secretOrKey: secret,
    });
  }

  async validate(payload: { sub: string; email: string; slug: string }) {
    const tenant = await this.prisma.tenant.findUnique({
      where: { id: payload.sub },
      select: {
        id: true,
        email: true,
        slug: true,
        name: true,
        status: true,
      },
    });

    if (!tenant) {
      throw new UnauthorizedException('Tenant tidak ditemukan');
    }

    if (tenant.status !== 'ACTIVE') {
      throw new UnauthorizedException('Akun tidak aktif');
    }

    return {
      id: tenant.id,
      email: tenant.email,
      slug: tenant.slug,
      name: tenant.name,
    };
  }
}



================================================================================
FILE: src/common/decorators/index.ts
================================================================================

export * from './tenant.decorator';



================================================================================
FILE: src/common/decorators/tenant.decorator.ts
================================================================================

import { createParamDecorator, ExecutionContext } from '@nestjs/common';

export interface TenantInfo {
  id: string;
  slug: string;
  name: string;
  email: string;
  category: string;
  status: string;
}

export const CurrentTenant = createParamDecorator(
  (data: keyof TenantInfo | undefined, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest();
    const tenant = request.user;

    if (!tenant) {
      return null;
    }

    return data ? tenant[data] : tenant;
  },
);



================================================================================
FILE: src/common/filters/index.ts
================================================================================

export * from './all-exceptions.filter';



================================================================================
FILE: src/common/filters/all-exceptions.filter.ts
================================================================================

import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
  HttpStatus,
  Logger,
} from '@nestjs/common';
import type { Response, Request } from 'express';
import { Prisma } from '@prisma/client';

/**
 * Global Exception Filter
 *
 * Catches all exceptions and returns consistent error responses.
 * Prevents internal error details from leaking to clients in production.
 */
@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  private readonly logger = new Logger('ExceptionFilter');

  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();

    let status = HttpStatus.INTERNAL_SERVER_ERROR;
    let message: string | string[] = 'Internal server error';
    let errors: string[] | undefined;
    let code: string | undefined;

    // Handle HTTP exceptions (BadRequest, NotFound, etc.)
    if (exception instanceof HttpException) {
      status = exception.getStatus();
      const exceptionResponse = exception.getResponse();

      if (typeof exceptionResponse === 'object' && exceptionResponse !== null) {
        const responseObj = exceptionResponse as Record<string, unknown>;
        message = (responseObj.message as string | string[]) || message;
        errors = responseObj.errors as string[] | undefined;
        code = responseObj.code as string | undefined;
      } else if (typeof exceptionResponse === 'string') {
        message = exceptionResponse;
      }
    }
    // Handle Prisma errors
    else if (exception instanceof Prisma.PrismaClientKnownRequestError) {
      const prismaError = this.handlePrismaError(exception);
      status = prismaError.status;
      message = prismaError.message;
      code = prismaError.code;
    }
    // Handle other errors
    else if (exception instanceof Error) {
      // Log full error internally
      this.logger.error(
        `Unhandled exception: ${exception.message}`,
        exception.stack,
      );

      // Don't expose internal errors in production
      if (process.env.NODE_ENV === 'production') {
        message = 'Internal server error';
      } else {
        message = exception.message;
      }
    }

    // Log all errors
    const messageStr = Array.isArray(message) ? message.join(', ') : message;
    this.logger.error(
      `${request.method} ${request.url} - ${status} - ${messageStr}`,
    );

    response.status(status).json({
      statusCode: status,
      message,
      errors,
      code,
      timestamp: new Date().toISOString(),
      path: request.url,
    });
  }

  private handlePrismaError(error: Prisma.PrismaClientKnownRequestError): {
    status: number;
    message: string;
    code: string;
  } {
    switch (error.code) {
      case 'P2002': {
        // Unique constraint violation
        // âœ… FIX: Wrap case content in braces to fix no-case-declarations
        const target = error.meta?.target;
        const field = Array.isArray(target) ? target.join(', ') : 'field';
        return {
          status: HttpStatus.CONFLICT,
          message: `Data dengan ${field} tersebut sudah ada`,
          code: 'DUPLICATE_ENTRY',
        };
      }

      case 'P2025':
        // Record not found
        return {
          status: HttpStatus.NOT_FOUND,
          message: 'Data tidak ditemukan',
          code: 'NOT_FOUND',
        };

      case 'P2003':
        // Foreign key constraint
        return {
          status: HttpStatus.BAD_REQUEST,
          message: 'Referensi data tidak valid',
          code: 'INVALID_REFERENCE',
        };

      case 'P2014':
        // Relation violation
        return {
          status: HttpStatus.BAD_REQUEST,
          message: 'Tidak dapat menghapus data yang masih memiliki relasi',
          code: 'RELATION_VIOLATION',
        };

      default:
        return {
          status: HttpStatus.BAD_REQUEST,
          message: 'Database operation failed',
          code: 'DATABASE_ERROR',
        };
    }
  }
}



================================================================================
FILE: src/common/guards/index.ts
================================================================================

export * from './jwt-auth.guard';



================================================================================
FILE: src/common/guards/jwt-auth.guard.ts
================================================================================

import {
  Injectable,
  ExecutionContext,
  UnauthorizedException,
} from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
import { Observable } from 'rxjs';

const COOKIE_NAME = 'fibidy_auth';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {
    const request = context.switchToHttp().getRequest();

    const cookieToken = request.cookies?.[COOKIE_NAME];
    const headerToken = request.headers.authorization?.replace('Bearer ', '');

    if (!cookieToken && !headerToken) {
      throw new UnauthorizedException('Token tidak ditemukan');
    }

    return super.canActivate(context);
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  handleRequest<TUser = any>(err: any, user: TUser, _info: any): TUser {
    if (err || !user) {
      throw err || new UnauthorizedException('Autentikasi gagal');
    }
    return user;
  }
}



================================================================================
FILE: src/common/interceptors/index.ts
================================================================================

export * from './logging.interceptor';



================================================================================
FILE: src/common/interceptors/logging.interceptor.ts
================================================================================

import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
  Logger,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';
import { Request } from 'express';

/**
 * Logging Interceptor
 *
 * Logs all HTTP requests with timing information.
 * Useful for debugging, monitoring, and audit trails.
 */
@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  private readonly logger = new Logger('HTTP');

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const request = context.switchToHttp().getRequest<Request>();
    const { method, url, ip } = request;

    // Get tenant ID from authenticated user (if available)
    const tenantId = (request as any).user?.id || 'anonymous';

    const now = Date.now();

    return next.handle().pipe(
      tap({
        next: () => {
          const response = context.switchToHttp().getResponse();
          const duration = Date.now() - now;

          // Log successful requests
          this.logger.log(
            `${method} ${url} ${response.statusCode} - ${duration}ms - ${ip} - ${tenantId}`,
          );
        },
        error: (error) => {
          const duration = Date.now() - now;

          // Log failed requests
          this.logger.error(
            `${method} ${url} ${error.status || 500} - ${duration}ms - ${ip} - ${tenantId} - ${error.message}`,
          );
        },
      }),
    );
  }
}



================================================================================
FILE: src/common/pipes/index.ts
================================================================================

export * from './sanitize.pipe';



================================================================================
FILE: src/common/pipes/sanitize.pipe.ts
================================================================================

import { PipeTransform, Injectable, ArgumentMetadata } from '@nestjs/common';

/**
 * Sanitize Pipe - XSS Prevention
 *
 * Removes potentially dangerous HTML/script content from string inputs.
 * Applied globally before ValidationPipe.
 */
@Injectable()
export class SanitizePipe implements PipeTransform {
  transform(value: unknown, metadata: ArgumentMetadata): unknown {
    // Only sanitize body parameters
    if (metadata.type !== 'body') {
      return value;
    }

    return this.sanitizeValue(value);
  }

  private sanitizeValue(value: unknown): unknown {
    // Handle null/undefined
    if (value === null || value === undefined) {
      return value;
    }

    // Sanitize strings
    if (typeof value === 'string') {
      return this.sanitizeString(value);
    }

    // Sanitize arrays
    if (Array.isArray(value)) {
      return value.map((item: unknown) => this.sanitizeValue(item));
    }

    // Sanitize objects
    if (typeof value === 'object') {
      const sanitized: Record<string, unknown> = {};
      for (const key of Object.keys(value as Record<string, unknown>)) {
        sanitized[key] = this.sanitizeValue(
          (value as Record<string, unknown>)[key],
        );
      }
      return sanitized;
    }

    // Return other types as-is (number, boolean, etc.)
    return value;
  }

  private sanitizeString(str: string): string {
    // Remove script tags and their content
    str = str.replace(
      /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
      '',
    );

    // Remove onclick, onerror, and other event handlers
    str = str.replace(/\s*on\w+\s*=\s*(['"])[^'"]*\1/gi, '');
    str = str.replace(/\s*on\w+\s*=\s*[^\s>]+/gi, '');

    // Remove javascript: protocol
    str = str.replace(/javascript:/gi, '');

    // Remove data: protocol (can be used for XSS)
    str = str.replace(/data:/gi, '');

    // Encode dangerous characters
    str = str.replace(/</g, '&lt;').replace(/>/g, '&gt;');

    return str.trim();
  }
}



================================================================================
FILE: src/common/utils/index.ts
================================================================================





================================================================================
FILE: src/common/utils/helpers.ts
================================================================================





================================================================================
FILE: src/customers/customers.module.ts
================================================================================

import { Module } from '@nestjs/common';
import { CustomersService } from './customers.service';
import { CustomersController } from './customers.controller';

@Module({
  controllers: [CustomersController],
  providers: [CustomersService],
  exports: [CustomersService],
})
export class CustomersModule {}



================================================================================
FILE: src/customers/customers.controller.ts
================================================================================

import {
  Controller,
  Get,
  Post,
  Patch,
  Delete,
  Body,
  Param,
  Query,
  UseGuards,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { CustomersService } from './customers.service';
import { CreateCustomerDto, UpdateCustomerDto, QueryCustomerDto } from './dto';
import { JwtAuthGuard } from '../common/guards/jwt-auth.guard';
import { CurrentTenant } from '../common/decorators/tenant.decorator';

@Controller('customers')
@UseGuards(JwtAuthGuard)
export class CustomersController {
  constructor(private customersService: CustomersService) {}

  @Post()
  @HttpCode(HttpStatus.CREATED)
  async create(
    @CurrentTenant('id') tenantId: string,
    @Body() dto: CreateCustomerDto,
  ) {
    return this.customersService.create(tenantId, dto);
  }

  @Get()
  async findAll(
    @CurrentTenant('id') tenantId: string,
    @Query() query: QueryCustomerDto,
  ) {
    return this.customersService.findAll(tenantId, query);
  }

  @Get(':id')
  async findOne(
    @CurrentTenant('id') tenantId: string,
    @Param('id') customerId: string,
  ) {
    return this.customersService.findOne(tenantId, customerId);
  }

  @Patch(':id')
  async update(
    @CurrentTenant('id') tenantId: string,
    @Param('id') customerId: string,
    @Body() dto: UpdateCustomerDto,
  ) {
    return this.customersService.update(tenantId, customerId, dto);
  }

  @Delete(':id')
  async remove(
    @CurrentTenant('id') tenantId: string,
    @Param('id') customerId: string,
  ) {
    return this.customersService.remove(tenantId, customerId);
  }

  @Get(':id/orders')
  async findCustomerOrders(
    @CurrentTenant('id') tenantId: string,
    @Param('id') customerId: string,
  ) {
    return this.customersService.findCustomerOrders(tenantId, customerId);
  }
}



================================================================================
FILE: src/customers/customers.service.ts
================================================================================

import {
  Injectable,
  NotFoundException,
  ConflictException,
} from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { CreateCustomerDto, UpdateCustomerDto, QueryCustomerDto } from './dto';
import { Prisma } from '@prisma/client';

@Injectable()
export class CustomersService {
  constructor(private prisma: PrismaService) {}

  // ==========================================
  // CREATE CUSTOMER
  // ==========================================
  async create(tenantId: string, dto: CreateCustomerDto) {
    // Normalize phone number
    const phone = this.normalizePhone(dto.phone);

    // Check phone uniqueness within tenant
    const existing = await this.prisma.customer.findUnique({
      where: {
        tenantId_phone: { tenantId, phone },
      },
    });

    if (existing) {
      throw new ConflictException(
        `Pelanggan dengan nomor ${phone} sudah terdaftar`,
      );
    }

    const customer = await this.prisma.customer.create({
      data: {
        tenantId,
        name: dto.name,
        phone,
        email: dto.email,
        address: dto.address,
        metadata: dto.metadata ?? {},
      },
    });

    return {
      message: 'Pelanggan berhasil ditambahkan',
      customer,
    };
  }

  // ==========================================
  // FIND ALL CUSTOMERS
  // ==========================================
  async findAll(tenantId: string, query: QueryCustomerDto) {
    const {
      search,
      sortBy = 'createdAt',
      sortOrder = 'desc',
      page = 1,
      limit = 20,
    } = query;

    const where: Prisma.CustomerWhereInput = { tenantId };

    if (search) {
      where.OR = [
        { name: { contains: search, mode: 'insensitive' } },
        { phone: { contains: search } },
        { email: { contains: search, mode: 'insensitive' } },
      ];
    }

    const orderBy: Prisma.CustomerOrderByWithRelationInput = {
      [sortBy]: sortOrder,
    };

    const skip = (page - 1) * limit;

    const [customers, total] = await Promise.all([
      this.prisma.customer.findMany({
        where,
        orderBy,
        skip,
        take: limit,
        select: {
          id: true,
          name: true,
          phone: true,
          email: true,
          address: true,
          metadata: true,
          totalOrders: true,
          totalSpent: true,
          createdAt: true,
        },
      }),
      this.prisma.customer.count({ where }),
    ]);

    return {
      data: customers,
      meta: {
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  // ==========================================
  // FIND ONE CUSTOMER
  // ==========================================
  async findOne(tenantId: string, customerId: string) {
    const customer = await this.prisma.customer.findFirst({
      where: {
        id: customerId,
        tenantId,
      },
      include: {
        _count: {
          select: { orders: true },
        },
      },
    });

    if (!customer) {
      throw new NotFoundException('Pelanggan tidak ditemukan');
    }

    return customer;
  }

  // ==========================================
  // UPDATE CUSTOMER
  // ==========================================
  async update(tenantId: string, customerId: string, dto: UpdateCustomerDto) {
    const existing = await this.prisma.customer.findFirst({
      where: { id: customerId, tenantId },
    });

    if (!existing) {
      throw new NotFoundException('Pelanggan tidak ditemukan');
    }

    // Check phone uniqueness if updating phone
    if (dto.phone) {
      const phone = this.normalizePhone(dto.phone);
      const phoneExists = await this.prisma.customer.findFirst({
        where: {
          tenantId,
          phone,
          id: { not: customerId },
        },
      });

      if (phoneExists) {
        throw new ConflictException(
          `Nomor ${phone} sudah digunakan pelanggan lain`,
        );
      }
      dto.phone = phone;
    }

    const customer = await this.prisma.customer.update({
      where: { id: customerId },
      data: {
        name: dto.name,
        phone: dto.phone,
        email: dto.email,
        address: dto.address,
        metadata: dto.metadata,
      },
    });

    return {
      message: 'Pelanggan berhasil diupdate',
      customer,
    };
  }

  // ==========================================
  // DELETE CUSTOMER
  // ==========================================
  async remove(tenantId: string, customerId: string) {
    const existing = await this.prisma.customer.findFirst({
      where: { id: customerId, tenantId },
      include: { _count: { select: { orders: true } } },
    });

    if (!existing) {
      throw new NotFoundException('Pelanggan tidak ditemukan');
    }

    if (existing._count.orders > 0) {
      throw new ConflictException(
        `Tidak dapat menghapus pelanggan yang memiliki ${existing._count.orders} order`,
      );
    }

    await this.prisma.customer.delete({
      where: { id: customerId },
    });

    return { message: 'Pelanggan berhasil dihapus' };
  }

  // ==========================================
  // GET CUSTOMER ORDERS
  // ==========================================
  async findCustomerOrders(tenantId: string, customerId: string) {
    const customer = await this.prisma.customer.findFirst({
      where: { id: customerId, tenantId },
    });

    if (!customer) {
      throw new NotFoundException('Pelanggan tidak ditemukan');
    }

    const orders = await this.prisma.order.findMany({
      where: { customerId },
      orderBy: { createdAt: 'desc' },
      select: {
        id: true,
        orderNumber: true,
        total: true,
        status: true,
        paymentStatus: true,
        createdAt: true,
      },
    });

    return { customer: { id: customer.id, name: customer.name }, orders };
  }

  // ==========================================
  // HELPER: Normalize phone number
  // ==========================================
  private normalizePhone(phone: string): string {
    let normalized = phone.replace(/\D/g, '');
    if (normalized.startsWith('0')) {
      normalized = '62' + normalized.substring(1);
    }
    if (!normalized.startsWith('62')) {
      normalized = '62' + normalized;
    }
    return normalized;
  }
}



================================================================================
FILE: src/customers/dto/index.ts
================================================================================

export * from './create-customer.dto';
export * from './update-customer.dto';
export * from './query-customer.dto';



================================================================================
FILE: src/customers/dto/create-customer.dto.ts
================================================================================

import {
  IsString,
  IsNotEmpty,
  IsOptional,
  IsEmail,
  IsObject,
  MaxLength,
  Matches,
} from 'class-validator';

export class CreateCustomerDto {
  @IsString()
  @IsNotEmpty({ message: 'Nama pelanggan tidak boleh kosong' })
  @MaxLength(100, { message: 'Nama maksimal 100 karakter' })
  name: string;

  @IsString()
  @IsNotEmpty({ message: 'Nomor telepon tidak boleh kosong' })
  @Matches(/^(\+62|62|0)[0-9]{9,13}$/, {
    message: 'Format nomor telepon tidak valid',
  })
  phone: string;

  @IsOptional()
  @IsEmail({}, { message: 'Format email tidak valid' })
  email?: string;

  @IsOptional()
  @IsString()
  @MaxLength(300, { message: 'Alamat maksimal 300 karakter' })
  address?: string;

  @IsOptional()
  @IsObject()
  metadata?: Record<string, any>;
  // WARUNG: { totalDebt: 0, creditLimit: 200000 }
  // BENGKEL: { vehicles: [{ plate: "B 1234 XY", brand: "Honda" }] }
  // SALON: { preferences: "..." }
}



================================================================================
FILE: src/customers/dto/update-customer.dto.ts
================================================================================

import { PartialType } from '@nestjs/mapped-types';
import { CreateCustomerDto } from './create-customer.dto';

export class UpdateCustomerDto extends PartialType(CreateCustomerDto) {}



================================================================================
FILE: src/customers/dto/query-customer.dto.ts
================================================================================

import { IsOptional, IsString, IsNumber, Min } from 'class-validator';
import { Type } from 'class-transformer';

export class QueryCustomerDto {
  @IsOptional()
  @IsString()
  search?: string;

  @IsOptional()
  @IsString()
  sortBy?: 'name' | 'totalOrders' | 'totalSpent' | 'createdAt';

  @IsOptional()
  @IsString()
  sortOrder?: 'asc' | 'desc';

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  @Min(1)
  page?: number = 1;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  @Min(1)
  limit?: number = 20;
}



================================================================================
FILE: src/database/database.module.ts
================================================================================





================================================================================
FILE: src/database/prisma.service.ts
================================================================================





================================================================================
FILE: src/database/index.ts
================================================================================





================================================================================
FILE: src/orders/orders.module.ts
================================================================================

import { Module } from '@nestjs/common';
import { OrdersService } from './orders.service';
import { OrdersController } from './orders.controller';

@Module({
  controllers: [OrdersController],
  providers: [OrdersService],
  exports: [OrdersService],
})
export class OrdersModule {}



================================================================================
FILE: src/orders/orders.controller.ts
================================================================================

import {
  Controller,
  Get,
  Post,
  Patch,
  Delete,
  Body,
  Param,
  Query,
  UseGuards,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { OrdersService } from './orders.service';
import {
  CreateOrderDto,
  UpdateOrderDto,
  UpdateOrderStatusDto,
  UpdatePaymentStatusDto,
  QueryOrderDto,
} from './dto';
import { JwtAuthGuard } from '../common/guards/jwt-auth.guard';
import { CurrentTenant } from '../common/decorators/tenant.decorator';

@Controller('orders')
@UseGuards(JwtAuthGuard)
export class OrdersController {
  constructor(private ordersService: OrdersService) {}

  @Post()
  @HttpCode(HttpStatus.CREATED)
  async create(
    @CurrentTenant('id') tenantId: string,
    @Body() dto: CreateOrderDto,
  ) {
    return this.ordersService.create(tenantId, dto);
  }

  @Get()
  async findAll(
    @CurrentTenant('id') tenantId: string,
    @Query() query: QueryOrderDto,
  ) {
    return this.ordersService.findAll(tenantId, query);
  }

  @Get(':id')
  async findOne(
    @CurrentTenant('id') tenantId: string,
    @Param('id') orderId: string,
  ) {
    return this.ordersService.findOne(tenantId, orderId);
  }

  @Patch(':id')
  async update(
    @CurrentTenant('id') tenantId: string,
    @Param('id') orderId: string,
    @Body() dto: UpdateOrderDto,
  ) {
    return this.ordersService.update(tenantId, orderId, dto);
  }

  @Patch(':id/status')
  async updateStatus(
    @CurrentTenant('id') tenantId: string,
    @Param('id') orderId: string,
    @Body() dto: UpdateOrderStatusDto,
  ) {
    return this.ordersService.updateStatus(tenantId, orderId, dto);
  }

  @Patch(':id/payment')
  async updatePaymentStatus(
    @CurrentTenant('id') tenantId: string,
    @Param('id') orderId: string,
    @Body() dto: UpdatePaymentStatusDto,
  ) {
    return this.ordersService.updatePaymentStatus(tenantId, orderId, dto);
  }

  // âœ… NEW: Cancel order endpoint
  @Patch(':id/cancel')
  @HttpCode(HttpStatus.OK)
  async cancel(
    @CurrentTenant('id') tenantId: string,
    @Param('id') orderId: string,
  ) {
    return this.ordersService.cancelOrder(tenantId, orderId);
  }

  @Delete(':id')
  async remove(
    @CurrentTenant('id') tenantId: string,
    @Param('id') orderId: string,
  ) {
    return this.ordersService.remove(tenantId, orderId);
  }
}



================================================================================
FILE: src/orders/orders.service.ts
================================================================================

import {
  Injectable,
  NotFoundException,
  BadRequestException,
} from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { RedisService, CACHE_KEYS } from '../redis/redis.service';
import {
  CreateOrderDto,
  UpdateOrderDto,
  UpdateOrderStatusDto,
  UpdatePaymentStatusDto,
  QueryOrderDto,
} from './dto';
import { Prisma, OrderStatus, PaymentStatus } from '@prisma/client';

@Injectable()
export class OrdersService {
  constructor(
    private prisma: PrismaService,
    private redis: RedisService,
  ) {}

  // ==========================================
  // CREATE ORDER
  // ==========================================
  async create(tenantId: string, dto: CreateOrderDto) {
    if (dto.customerId) {
      const customer = await this.prisma.customer.findFirst({
        where: { id: dto.customerId, tenantId },
      });
      if (!customer) {
        throw new BadRequestException('Pelanggan tidak ditemukan');
      }
    }

    const itemsWithSubtotal = dto.items.map((item) => ({
      ...item,
      subtotal: item.price * item.qty,
    }));

    const subtotal = itemsWithSubtotal.reduce(
      (sum, item) => sum + item.subtotal,
      0,
    );
    const discount = dto.discount ?? 0;
    const tax = dto.tax ?? 0;
    const total = subtotal - discount + tax;

    const orderNumber = await this.generateOrderNumber(tenantId);

    const order = await this.prisma.order.create({
      data: {
        tenantId,
        customerId: dto.customerId,
        orderNumber,
        subtotal,
        discount,
        tax,
        total,
        paymentMethod: dto.paymentMethod,
        paymentStatus: PaymentStatus.PENDING,
        status: OrderStatus.PENDING,
        customerName: dto.customerName,
        customerPhone: dto.customerPhone,
        notes: dto.notes,
        metadata: dto.metadata ?? {},
        items: {
          create: itemsWithSubtotal.map((item) => ({
            productId: item.productId,
            name: item.name,
            price: item.price,
            qty: item.qty,
            subtotal: item.subtotal,
            notes: item.notes,
          })),
        },
      },
      include: {
        items: true,
        customer: {
          select: { id: true, name: true, phone: true },
        },
      },
    });

    if (dto.customerId) {
      await this.prisma.customer.update({
        where: { id: dto.customerId },
        data: { totalOrders: { increment: 1 } },
      });
    }

    // ðŸ”¥ Invalidate dashboard stats
    await this.redis.invalidateStats(tenantId);

    return {
      message: 'Order berhasil dibuat',
      order,
    };
  }

  // ==========================================
  // FIND ALL ORDERS
  // ==========================================
  async findAll(tenantId: string, query: QueryOrderDto) {
    const {
      search,
      status,
      paymentStatus,
      customerId,
      dateFrom,
      dateTo,
      sortBy = 'createdAt',
      sortOrder = 'desc',
      page = 1,
      limit = 20,
    } = query;

    const where: Prisma.OrderWhereInput = { tenantId };

    if (search) {
      where.orderNumber = { contains: search, mode: 'insensitive' };
    }

    if (status) where.status = status;
    if (paymentStatus) where.paymentStatus = paymentStatus;
    if (customerId) where.customerId = customerId;

    if (dateFrom || dateTo) {
      where.createdAt = {};
      if (dateFrom) where.createdAt.gte = new Date(dateFrom);
      if (dateTo) where.createdAt.lte = new Date(dateTo);
    }

    const orderBy: Prisma.OrderOrderByWithRelationInput = {
      [sortBy]: sortOrder,
    };

    const skip = (page - 1) * limit;

    const [orders, total] = await Promise.all([
      this.prisma.order.findMany({
        where,
        orderBy,
        skip,
        take: limit,
        select: {
          id: true,
          orderNumber: true,
          subtotal: true,
          discount: true,
          total: true,
          status: true,
          paymentStatus: true,
          paymentMethod: true,
          customerName: true,
          customerPhone: true,
          createdAt: true,
          customer: {
            select: { id: true, name: true, phone: true },
          },
          _count: { select: { items: true } },
        },
      }),
      this.prisma.order.count({ where }),
    ]);

    return {
      data: orders,
      meta: {
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  // ==========================================
  // FIND ONE ORDER
  // ==========================================
  async findOne(tenantId: string, orderId: string) {
    const order = await this.prisma.order.findFirst({
      where: { id: orderId, tenantId },
      include: {
        items: {
          include: {
            product: {
              select: { id: true, name: true, images: true },
            },
          },
        },
        customer: {
          select: {
            id: true,
            name: true,
            phone: true,
            email: true,
            address: true,
          },
        },
      },
    });

    if (!order) {
      throw new NotFoundException('Order tidak ditemukan');
    }

    return order;
  }

  // ==========================================
  // UPDATE ORDER
  // ==========================================
  async update(tenantId: string, orderId: string, dto: UpdateOrderDto) {
    const existing = await this.prisma.order.findFirst({
      where: { id: orderId, tenantId },
    });

    if (!existing) {
      throw new NotFoundException('Order tidak ditemukan');
    }

    if (existing.status === 'COMPLETED' || existing.status === 'CANCELLED') {
      throw new BadRequestException(
        'Tidak dapat mengubah order yang sudah selesai atau dibatalkan',
      );
    }

    let total = existing.total;
    if (dto.discount !== undefined) {
      total = existing.subtotal - dto.discount + existing.tax;
    }

    const order = await this.prisma.order.update({
      where: { id: orderId },
      data: {
        discount: dto.discount,
        total: dto.discount !== undefined ? total : undefined,
        paymentMethod: dto.paymentMethod,
        notes: dto.notes,
        metadata: dto.metadata,
      },
      include: { items: true },
    });

    // ðŸ”¥ Invalidate stats
    await this.redis.invalidateStats(tenantId);

    return { message: 'Order berhasil diupdate', order };
  }

  // ==========================================
  // ðŸš€ OPTIMIZED: UPDATE ORDER STATUS
  // Fixed N+1 Query Problem!
  // ==========================================
  async updateStatus(
    tenantId: string,
    orderId: string,
    dto: UpdateOrderStatusDto,
  ) {
    const existing = await this.prisma.order.findFirst({
      where: { id: orderId, tenantId },
      include: { items: true },
    });

    if (!existing) {
      throw new NotFoundException('Order tidak ditemukan');
    }

    const updateData: Prisma.OrderUpdateInput = {
      status: dto.status,
    };

    if (dto.status === 'COMPLETED') {
      updateData.completedAt = new Date();

      // Update customer totalSpent
      if (existing.customerId && existing.paymentStatus === 'PAID') {
        await this.prisma.customer.update({
          where: { id: existing.customerId },
          data: { totalSpent: { increment: existing.total } },
        });
      }

      // ==========================================
      // ðŸš€ OPTIMIZATION: Batch stock update
      // Instead of N queries, we do 1 query to get all products
      // Then 1 updateMany per product (but batched)
      // ==========================================
      const productIds = existing.items
        .map((item) => item.productId)
        .filter((id): id is string => id !== null);

      if (productIds.length > 0) {
        // Get all products at once (1 query instead of N)
        const products = await this.prisma.product.findMany({
          where: {
            id: { in: productIds },
            trackStock: true,
          },
          select: { id: true, stock: true },
        });

        const productMap = new Map(products.map((p) => [p.id, p]));

        // Prepare batch updates
        const stockUpdates: Promise<any>[] = [];

        for (const item of existing.items) {
          if (item.productId && productMap.has(item.productId)) {
            stockUpdates.push(
              this.prisma.product.update({
                where: { id: item.productId },
                data: { stock: { decrement: item.qty } },
              }),
            );
          }
        }

        // Execute all updates in parallel
        if (stockUpdates.length > 0) {
          await Promise.all(stockUpdates);
        }
      }
    }

    const order = await this.prisma.order.update({
      where: { id: orderId },
      data: updateData,
      select: {
        id: true,
        orderNumber: true,
        status: true,
        completedAt: true,
      },
    });

    // ðŸ”¥ Invalidate stats and low stock cache
    await this.redis.invalidateStats(tenantId);
    await this.redis.del(CACHE_KEYS.PRODUCT_LOW_STOCK(tenantId));

    return { message: `Status order diubah ke ${dto.status}`, order };
  }

  // ==========================================
  // UPDATE PAYMENT STATUS
  // ==========================================
  async updatePaymentStatus(
    tenantId: string,
    orderId: string,
    dto: UpdatePaymentStatusDto,
  ) {
    const existing = await this.prisma.order.findFirst({
      where: { id: orderId, tenantId },
    });

    if (!existing) {
      throw new NotFoundException('Order tidak ditemukan');
    }

    const order = await this.prisma.order.update({
      where: { id: orderId },
      data: {
        paymentStatus: dto.paymentStatus,
        paidAmount: dto.paidAmount ?? existing.paidAmount,
      },
      select: {
        id: true,
        orderNumber: true,
        total: true,
        paymentStatus: true,
        paidAmount: true,
      },
    });

    // ðŸ”¥ Invalidate stats
    await this.redis.invalidateStats(tenantId);

    return {
      message: `Status pembayaran diubah ke ${dto.paymentStatus}`,
      order,
    };
  }

  // ==========================================
  // DELETE ORDER
  // ==========================================
  async remove(tenantId: string, orderId: string) {
    const existing = await this.prisma.order.findFirst({
      where: { id: orderId, tenantId },
    });

    if (!existing) {
      throw new NotFoundException('Order tidak ditemukan');
    }

    if (existing.status === 'COMPLETED') {
      throw new BadRequestException(
        'Tidak dapat menghapus order yang sudah selesai',
      );
    }

    if (existing.customerId) {
      await this.prisma.customer.update({
        where: { id: existing.customerId },
        data: { totalOrders: { decrement: 1 } },
      });
    }

    await this.prisma.order.delete({ where: { id: orderId } });

    // ðŸ”¥ Invalidate stats
    await this.redis.invalidateStats(tenantId);

    return { message: 'Order berhasil dihapus' };
  }

  // ==========================================
  // CANCEL ORDER
  // ==========================================
  async cancelOrder(tenantId: string, orderId: string) {
    const existing = await this.prisma.order.findFirst({
      where: { id: orderId, tenantId },
    });

    if (!existing) {
      throw new NotFoundException('Order tidak ditemukan');
    }

    if (existing.status === 'COMPLETED') {
      throw new BadRequestException(
        'Tidak dapat membatalkan order yang sudah selesai',
      );
    }

    if (existing.status === 'CANCELLED') {
      throw new BadRequestException('Order sudah dibatalkan');
    }

    const order = await this.prisma.order.update({
      where: { id: orderId },
      data: {
        status: 'CANCELLED',
        paymentStatus: 'FAILED',
      },
      select: {
        id: true,
        orderNumber: true,
        status: true,
        paymentStatus: true,
      },
    });

    if (existing.customerId) {
      await this.prisma.customer.update({
        where: { id: existing.customerId },
        data: { totalOrders: { decrement: 1 } },
      });
    }

    // ðŸ”¥ Invalidate stats
    await this.redis.invalidateStats(tenantId);

    return {
      message: 'Order berhasil dibatalkan',
      order,
    };
  }

  // ==========================================
  // HELPER: Generate Order Number
  // ==========================================
  private async generateOrderNumber(tenantId: string): Promise<string> {
    const today = new Date();
    const dateStr = today.toISOString().split('T')[0].replace(/-/g, '');

    const startOfDay = new Date(today.setHours(0, 0, 0, 0));
    const endOfDay = new Date(today.setHours(23, 59, 59, 999));

    const count = await this.prisma.order.count({
      where: {
        tenantId,
        createdAt: { gte: startOfDay, lte: endOfDay },
      },
    });

    const sequence = String(count + 1).padStart(3, '0');
    return `ORD-${dateStr}-${sequence}`;
  }
}



================================================================================
FILE: src/orders/dto/index.ts
================================================================================

export * from './create-order-item.dto';
export * from './create-order.dto';
export * from './update-order.dto';
export * from './update-status.dto';
export * from './query-order.dto';



================================================================================
FILE: src/orders/dto/create-order.dto.ts
================================================================================

import {
  IsString,
  IsOptional,
  IsNumber,
  IsArray,
  IsObject,
  ValidateNested,
  ArrayMinSize,
  Min,
} from 'class-validator';
import { Type } from 'class-transformer';
import { CreateOrderItemDto } from './create-order-item.dto';

export class CreateOrderDto {
  @IsOptional()
  @IsString()
  customerId?: string;

  // For guest orders (without customerId)
  @IsOptional()
  @IsString()
  customerName?: string;

  @IsOptional()
  @IsString()
  customerPhone?: string;

  @IsArray()
  @ArrayMinSize(1, { message: 'Minimal 1 item dalam order' })
  @ValidateNested({ each: true })
  @Type(() => CreateOrderItemDto)
  items: CreateOrderItemDto[];

  @IsOptional()
  @IsNumber()
  @Min(0)
  @Type(() => Number)
  discount?: number;

  @IsOptional()
  @IsNumber()
  @Min(0)
  @Type(() => Number)
  tax?: number;

  @IsOptional()
  @IsString()
  paymentMethod?: string; // cash, transfer, qris, debt

  @IsOptional()
  @IsString()
  notes?: string;

  @IsOptional()
  @IsObject()
  metadata?: Record<string, any>;
  // LAUNDRY: { weight: 3.5, pickupDate: "..." }
  // CATERING: { deliveryDate: "...", deliveryAddress: "..." }
}



================================================================================
FILE: src/orders/dto/create-order-item.dto.ts
================================================================================

import {
  IsString,
  IsNotEmpty,
  IsOptional,
  IsNumber,
  Min,
} from 'class-validator';
import { Type } from 'class-transformer';

export class CreateOrderItemDto {
  @IsOptional()
  @IsString()
  productId?: string;

  @IsString()
  @IsNotEmpty({ message: 'Nama item tidak boleh kosong' })
  name: string;

  @IsNumber()
  @Min(0, { message: 'Harga tidak boleh negatif' })
  @Type(() => Number)
  price: number;

  @IsNumber()
  @Min(1, { message: 'Jumlah minimal 1' })
  @Type(() => Number)
  qty: number;

  @IsOptional()
  @IsString()
  notes?: string;
}



================================================================================
FILE: src/orders/dto/update-order.dto.ts
================================================================================

import { IsString, IsOptional, IsNumber, IsObject, Min } from 'class-validator';
import { Type } from 'class-transformer';

export class UpdateOrderDto {
  @IsOptional()
  @IsNumber()
  @Min(0)
  @Type(() => Number)
  discount?: number;

  @IsOptional()
  @IsString()
  paymentMethod?: string;

  @IsOptional()
  @IsString()
  notes?: string;

  @IsOptional()
  @IsObject()
  metadata?: Record<string, any>;
}



================================================================================
FILE: src/orders/dto/update-status.dto.ts
================================================================================

import { IsString, IsNotEmpty, IsIn, IsOptional } from 'class-validator';

export class UpdateOrderStatusDto {
  @IsString()
  @IsNotEmpty()
  @IsIn(['PENDING', 'PROCESSING', 'COMPLETED', 'CANCELLED'])
  status: 'PENDING' | 'PROCESSING' | 'COMPLETED' | 'CANCELLED';
}

export class UpdatePaymentStatusDto {
  @IsString()
  @IsNotEmpty()
  @IsIn(['PENDING', 'PAID', 'PARTIAL', 'FAILED'])
  paymentStatus: 'PENDING' | 'PAID' | 'PARTIAL' | 'FAILED';

  @IsOptional()
  paidAmount?: number;
}



================================================================================
FILE: src/orders/dto/query-order.dto.ts
================================================================================

import { IsOptional, IsString, IsNumber, Min } from 'class-validator';
import { Type } from 'class-transformer';

export class QueryOrderDto {
  @IsOptional()
  @IsString()
  search?: string; // Search by orderNumber

  @IsOptional()
  @IsString()
  status?: 'PENDING' | 'PROCESSING' | 'COMPLETED' | 'CANCELLED';

  @IsOptional()
  @IsString()
  paymentStatus?: 'PENDING' | 'PAID' | 'PARTIAL' | 'FAILED';

  @IsOptional()
  @IsString()
  customerId?: string;

  @IsOptional()
  @IsString()
  dateFrom?: string; // ISO date

  @IsOptional()
  @IsString()
  dateTo?: string; // ISO date

  @IsOptional()
  @IsString()
  sortBy?: 'orderNumber' | 'total' | 'createdAt';

  @IsOptional()
  @IsString()
  sortOrder?: 'asc' | 'desc';

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  @Min(1)
  page?: number = 1;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  @Min(1)
  limit?: number = 20;
}



================================================================================
FILE: src/prisma/prisma.module.ts
================================================================================

import { Global, Module } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Global() // Makes PrismaService available everywhere without importing
@Module({
  providers: [PrismaService],
  exports: [PrismaService],
})
export class PrismaModule {}



================================================================================
FILE: src/prisma/prisma.service.ts
================================================================================

import { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService
  extends PrismaClient
  implements OnModuleInit, OnModuleDestroy
{
  constructor() {
    super({
      log:
        process.env.NODE_ENV === 'development'
          ? ['query', 'info', 'warn', 'error']
          : ['error'],
    });
  }

  async onModuleInit() {
    await this.$connect();
    console.log('âœ… Database connected');
  }

  async onModuleDestroy() {
    await this.$disconnect();
    console.log('âŒ Database disconnected');
  }

  // Helper untuk clean database (testing only)
  async cleanDatabase() {
    if (process.env.NODE_ENV === 'production') {
      throw new Error('Cannot clean database in production!');
    }

    // Delete in correct order (respect foreign keys)
    await this.orderItem.deleteMany();
    await this.order.deleteMany();
    await this.customer.deleteMany();
    await this.product.deleteMany();
    await this.tenant.deleteMany();
  }
}



================================================================================
FILE: src/products/products.module.ts
================================================================================

import { Module } from '@nestjs/common';
import { ProductsService } from './products.service';
import { ProductsController } from './products.controller';

@Module({
  controllers: [ProductsController],
  providers: [ProductsService],
  exports: [ProductsService],
})
export class ProductsModule {}



================================================================================
FILE: src/products/products.controller.ts
================================================================================

import {
  Controller,
  Get,
  Post,
  Patch,
  Delete,
  Body,
  Param,
  Query,
  UseGuards,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { ProductsService } from './products.service';
import {
  CreateProductDto,
  UpdateProductDto,
  QueryProductDto,
  UpdateStockDto,
  BulkDeleteDto,
} from './dto';
import { JwtAuthGuard } from '../common/guards/jwt-auth.guard';
import { CurrentTenant } from '../common/decorators/tenant.decorator';

@Controller('products')
export class ProductsController {
  constructor(private productsService: ProductsService) {}

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PUBLIC ENDPOINTS (No Auth Required)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /**
   * Get public product by ID (for OG images, SEO)
   * GET /api/products/public/:id
   */
  @Get('public/:id')
  async findPublicProduct(@Param('id') productId: string) {
    return this.productsService.findPublicProduct(productId);
  }

  /**
   * Get product by tenant slug and product slug (SEO-friendly URL)
   * GET /api/products/by-slug/:tenantSlug/:productSlug
   */
  @Get('by-slug/:tenantSlug/:productSlug')
  async findBySlug(
    @Param('tenantSlug') tenantSlug: string,
    @Param('productSlug') productSlug: string,
  ) {
    return this.productsService.findBySlug(tenantSlug, productSlug);
  }

  /**
   * Get products by store slug (for public store)
   * GET /api/products/store/:slug
   */
  @Get('store/:slug')
  async findByStoreSlug(
    @Param('slug') slug: string,
    @Query() query: QueryProductDto,
  ) {
    return this.productsService.findByStoreSlug(slug, query);
  }

  /**
   * Get single product by store slug and product ID (for public store)
   * GET /api/products/store/:slug/:productId
   */
  @Get('store/:slug/:productId')
  async findByStoreSlugAndProductId(
    @Param('slug') slug: string,
    @Param('productId') productId: string,
  ) {
    return this.productsService.findByStoreSlugAndProductId(slug, productId);
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PROTECTED ENDPOINTS (Auth Required)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /**
   * Create new product
   * POST /api/products
   */
  @Post()
  @UseGuards(JwtAuthGuard)
  @HttpCode(HttpStatus.CREATED)
  async create(
    @CurrentTenant('id') tenantId: string,
    @Body() dto: CreateProductDto,
  ) {
    return this.productsService.create(tenantId, dto);
  }

  /**
   * Get all products (with filters & pagination)
   * GET /api/products
   */
  @Get()
  @UseGuards(JwtAuthGuard)
  async findAll(
    @CurrentTenant('id') tenantId: string,
    @Query() query: QueryProductDto,
  ) {
    return this.productsService.findAll(tenantId, query);
  }

  /**
   * Get product categories (for filter dropdown)
   * GET /api/products/categories
   */
  @Get('categories')
  @UseGuards(JwtAuthGuard)
  async getCategories(@CurrentTenant('id') tenantId: string) {
    return this.productsService.getCategories(tenantId);
  }

  /**
   * Get low stock products
   * GET /api/products/low-stock
   */
  @Get('low-stock')
  @UseGuards(JwtAuthGuard)
  async getLowStock(@CurrentTenant('id') tenantId: string) {
    return this.productsService.getLowStock(tenantId);
  }

  /**
   * Bulk delete products
   * DELETE /api/products/bulk
   */
  @Delete('bulk')
  @UseGuards(JwtAuthGuard)
  @HttpCode(HttpStatus.OK)
  async bulkDelete(
    @CurrentTenant('id') tenantId: string,
    @Body() dto: BulkDeleteDto,
  ) {
    return this.productsService.bulkDelete(tenantId, dto.ids);
  }

  /**
   * Get single product
   * GET /api/products/:id
   */
  @Get(':id')
  @UseGuards(JwtAuthGuard)
  async findOne(
    @CurrentTenant('id') tenantId: string,
    @Param('id') productId: string,
  ) {
    return this.productsService.findOne(tenantId, productId);
  }

  /**
   * Update product
   * PATCH /api/products/:id
   */
  @Patch(':id')
  @UseGuards(JwtAuthGuard)
  async update(
    @CurrentTenant('id') tenantId: string,
    @Param('id') productId: string,
    @Body() dto: UpdateProductDto,
  ) {
    return this.productsService.update(tenantId, productId, dto);
  }

  /**
   * Update stock only
   * PATCH /api/products/:id/stock
   */
  @Patch(':id/stock')
  @UseGuards(JwtAuthGuard)
  async updateStock(
    @CurrentTenant('id') tenantId: string,
    @Param('id') productId: string,
    @Body() dto: UpdateStockDto,
  ) {
    return this.productsService.updateStock(tenantId, productId, dto);
  }

  /**
   * Toggle active status
   * PATCH /api/products/:id/toggle
   */
  @Patch(':id/toggle')
  @UseGuards(JwtAuthGuard)
  async toggleActive(
    @CurrentTenant('id') tenantId: string,
    @Param('id') productId: string,
  ) {
    return this.productsService.toggleActive(tenantId, productId);
  }

  /**
   * Delete product
   * DELETE /api/products/:id
   */
  @Delete(':id')
  @UseGuards(JwtAuthGuard)
  async remove(
    @CurrentTenant('id') tenantId: string,
    @Param('id') productId: string,
  ) {
    return this.productsService.remove(tenantId, productId);
  }
}



================================================================================
FILE: src/products/products.service.ts
================================================================================

import {
  Injectable,
  NotFoundException,
  ConflictException,
  BadRequestException,
} from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { RedisService, CACHE_TTL, CACHE_KEYS } from '../redis/redis.service';
import { SeoService } from '../seo/seo.service'; // ðŸš€ SEO SERVICE
import {
  CreateProductDto,
  UpdateProductDto,
  QueryProductDto,
  UpdateStockDto,
} from './dto';
import { Prisma } from '@prisma/client';

@Injectable()
export class ProductsService {
  constructor(
    private prisma: PrismaService,
    private redis: RedisService,
    private seoService: SeoService, // ðŸš€ SEO SERVICE INJECTION
  ) {}

  private generateSlug(name: string): string {
    return name
      .toLowerCase()
      .trim()
      .replace(/[^\w\s-]/g, '')
      .replace(/[\s_-]+/g, '-')
      .replace(/^-+|-+$/g, '');
  }

  private async ensureUniqueSlug(
    tenantId: string,
    baseSlug: string,
    excludeProductId?: string,
  ): Promise<string> {
    let slug = baseSlug;
    let counter = 1;

    while (true) {
      const existing = await this.prisma.product.findFirst({
        where: {
          tenantId,
          slug,
          ...(excludeProductId && { id: { not: excludeProductId } }),
        },
        select: { id: true },
      });

      if (!existing) return slug;

      slug = `${baseSlug}-${counter}`;
      counter++;

      if (counter > 100) {
        slug = `${baseSlug}-${Date.now()}`;
        break;
      }
    }

    return slug;
  }

  // ==========================================
  // PUBLIC METHODS
  // ==========================================

  async findPublicProduct(productId: string) {
    const cacheKey = CACHE_KEYS.PRODUCT_DETAIL(productId);

    return this.redis.getOrSet(
      cacheKey,
      async () => {
        const product = await this.prisma.product.findUnique({
          where: { id: productId },
          select: {
            id: true,
            name: true,
            slug: true,
            description: true,
            category: true,
            price: true,
            comparePrice: true,
            images: true,
            stock: true,
            trackStock: true,
            unit: true,
            isActive: true,
            tenant: {
              select: {
                id: true,
                slug: true,
                name: true,
                whatsapp: true,
                logo: true,
                status: true,
              },
            },
          },
        });

        if (!product) {
          throw new NotFoundException('Produk tidak ditemukan');
        }

        if (!product.isActive || product.tenant.status !== 'ACTIVE') {
          throw new NotFoundException('Produk tidak tersedia');
        }

        return product;
      },
      CACHE_TTL.PRODUCT_DETAIL,
    );
  }

  async findBySlug(tenantSlug: string, productSlug: string) {
    const cacheKey = CACHE_KEYS.PRODUCT_BY_SLUG(tenantSlug, productSlug);

    return this.redis.getOrSet(
      cacheKey,
      async () => {
        const tenant = await this.prisma.tenant.findUnique({
          where: { slug: tenantSlug.toLowerCase() },
          select: { id: true, status: true },
        });

        if (!tenant || tenant.status !== 'ACTIVE') {
          throw new NotFoundException('Toko tidak ditemukan');
        }

        const product = await this.prisma.product.findFirst({
          where: {
            tenantId: tenant.id,
            slug: productSlug.toLowerCase(),
            isActive: true,
          },
          select: {
            id: true,
            name: true,
            slug: true,
            description: true,
            category: true,
            price: true,
            comparePrice: true,
            images: true,
            stock: true,
            trackStock: true,
            unit: true,
            metadata: true,
            tenant: {
              select: {
                id: true,
                slug: true,
                name: true,
                whatsapp: true,
                logo: true,
              },
            },
          },
        });

        if (!product) {
          throw new NotFoundException('Produk tidak ditemukan');
        }

        return product;
      },
      CACHE_TTL.PRODUCT_DETAIL,
    );
  }

  async findByStoreSlug(slug: string, query: QueryProductDto) {
    const queryHash = this.redis.hashQuery({ ...query });
    const cacheKey = `store:products:${slug}:${queryHash}`;

    return this.redis.getOrSet(
      cacheKey,
      async () => {
        const tenant = await this.prisma.tenant.findUnique({
          where: { slug: slug.toLowerCase() },
          select: { id: true, status: true },
        });

        if (!tenant) {
          throw new NotFoundException(
            `Toko dengan slug "${slug}" tidak ditemukan`,
          );
        }

        if (tenant.status !== 'ACTIVE') {
          throw new NotFoundException('Toko tidak aktif');
        }

        const {
          search,
          category,
          isFeatured,
          sortBy = 'createdAt',
          sortOrder = 'desc',
          page = 1,
          limit = 20,
        } = query;

        const where: Prisma.ProductWhereInput = {
          tenantId: tenant.id,
          isActive: true,
        };

        if (search) {
          where.OR = [
            { name: { contains: search, mode: 'insensitive' } },
            { description: { contains: search, mode: 'insensitive' } },
          ];
        }

        if (category) where.category = category;
        if (typeof isFeatured === 'boolean') where.isFeatured = isFeatured;

        const orderBy: Prisma.ProductOrderByWithRelationInput = {
          [sortBy]: sortOrder,
        };

        const skip = (page - 1) * limit;

        const [products, total] = await Promise.all([
          this.prisma.product.findMany({
            where,
            orderBy,
            skip,
            take: limit,
            select: {
              id: true,
              name: true,
              slug: true,
              description: true,
              category: true,
              price: true,
              comparePrice: true,
              stock: true,
              trackStock: true,
              unit: true,
              images: true,
              isFeatured: true,
              createdAt: true,
            },
          }),
          this.prisma.product.count({ where }),
        ]);

        return {
          data: products,
          meta: {
            total,
            page,
            limit,
            totalPages: Math.ceil(total / limit),
          },
        };
      },
      CACHE_TTL.PRODUCT_LIST,
    );
  }

  async findByStoreSlugAndProductId(slug: string, productId: string) {
    const cacheKey = `store:product:${slug}:${productId}`;

    return this.redis.getOrSet(
      cacheKey,
      async () => {
        const tenant = await this.prisma.tenant.findUnique({
          where: { slug: slug.toLowerCase() },
          select: { id: true, status: true },
        });

        if (!tenant) {
          throw new NotFoundException(
            `Toko dengan slug "${slug}" tidak ditemukan`,
          );
        }

        if (tenant.status !== 'ACTIVE') {
          throw new NotFoundException('Toko tidak aktif');
        }

        const product = await this.prisma.product.findFirst({
          where: {
            id: productId,
            tenantId: tenant.id,
            isActive: true,
          },
          select: {
            id: true,
            tenantId: true,
            name: true,
            description: true,
            category: true,
            sku: true,
            price: true,
            comparePrice: true,
            stock: true,
            minStock: true,
            trackStock: true,
            unit: true,
            images: true,
            metadata: true,
            isActive: true,
            isFeatured: true,
            slug: true,
            createdAt: true,
            updatedAt: true,
          },
        });

        if (!product) {
          throw new NotFoundException(
            'Produk tidak ditemukan atau tidak aktif',
          );
        }

        return product;
      },
      CACHE_TTL.PRODUCT_DETAIL,
    );
  }

  // ==========================================
  // ðŸš€ CREATE - dengan SEO indexing
  // ==========================================
  async create(tenantId: string, dto: CreateProductDto) {
    if (dto.sku) {
      const existingSku = await this.prisma.product.findUnique({
        where: { tenantId_sku: { tenantId, sku: dto.sku } },
      });

      if (existingSku) {
        throw new ConflictException(`SKU "${dto.sku}" sudah digunakan`);
      }
    }

    const baseSlug = this.generateSlug(dto.name);
    const slug = await this.ensureUniqueSlug(tenantId, baseSlug);

    const product = await this.prisma.product.create({
      data: {
        tenantId,
        name: dto.name,
        slug,
        description: dto.description,
        category: dto.category,
        sku: dto.sku,
        price: dto.price,
        comparePrice: dto.comparePrice,
        costPrice: dto.costPrice,
        stock: dto.stock ?? 0,
        minStock: dto.minStock ?? 0,
        trackStock: dto.trackStock ?? false,
        unit: dto.unit,
        images: dto.images ?? [],
        metadata: dto.metadata ?? {},
        isActive: dto.isActive ?? true,
        isFeatured: dto.isFeatured ?? false,
      },
    });

    const tenant = await this.prisma.tenant.findUnique({
      where: { id: tenantId },
      select: { slug: true },
    });

    await this.redis.invalidateAllProductCaches(tenantId, tenant?.slug);

    // ðŸš€ SEO: Index new product
    if (tenant) {
      this.seoService
        .onProductCreated(tenant.slug, product.id, product.slug ?? undefined)
        .catch((error) => {
          console.error('[SEO] Failed to index new product:', error.message);
        });
    }

    return {
      message: 'Produk berhasil ditambahkan',
      product,
    };
  }

  // ==========================================
  // PROTECTED METHODS
  // ==========================================

  async findAll(tenantId: string, query: QueryProductDto) {
    const queryHash = this.redis.hashQuery({ ...query, tenantId });
    const cacheKey = CACHE_KEYS.PRODUCT_LIST(tenantId, queryHash);

    return this.redis.getOrSet(
      cacheKey,
      async () => {
        const {
          search,
          category,
          isActive,
          isFeatured,
          lowStock,
          sortBy = 'createdAt',
          sortOrder = 'desc',
          page = 1,
          limit = 20,
        } = query;

        const where: Prisma.ProductWhereInput = { tenantId };

        if (search) {
          where.OR = [
            { name: { contains: search, mode: 'insensitive' } },
            { description: { contains: search, mode: 'insensitive' } },
            { sku: { contains: search, mode: 'insensitive' } },
          ];
        }

        if (category) where.category = category;
        if (typeof isActive === 'boolean') where.isActive = isActive;
        if (typeof isFeatured === 'boolean') where.isFeatured = isFeatured;

        if (lowStock === true) {
          where.trackStock = true;
          where.stock = { lte: this.prisma.product.fields.minStock };
        }

        const orderBy: Prisma.ProductOrderByWithRelationInput = {
          [sortBy]: sortOrder,
        };

        const skip = (page - 1) * limit;

        const [products, total] = await Promise.all([
          this.prisma.product.findMany({
            where,
            orderBy,
            skip,
            take: limit,
            select: {
              id: true,
              name: true,
              slug: true,
              description: true,
              category: true,
              sku: true,
              price: true,
              comparePrice: true,
              costPrice: true,
              stock: true,
              minStock: true,
              trackStock: true,
              unit: true,
              images: true,
              isActive: true,
              isFeatured: true,
              createdAt: true,
              updatedAt: true,
            },
          }),
          this.prisma.product.count({ where }),
        ]);

        return {
          data: products,
          meta: {
            total,
            page,
            limit,
            totalPages: Math.ceil(total / limit),
          },
        };
      },
      CACHE_TTL.PRODUCT_LIST,
    );
  }

  async getCategories(tenantId: string) {
    const cacheKey = CACHE_KEYS.PRODUCT_CATEGORIES(tenantId);

    return this.redis.getOrSet(
      cacheKey,
      async () => {
        const products = await this.prisma.product.findMany({
          where: {
            tenantId,
            category: { not: null },
          },
          select: { category: true },
          distinct: ['category'],
          orderBy: { category: 'asc' },
        });

        const categories = products
          .map((p) => p.category)
          .filter((c): c is string => c !== null);

        return { categories };
      },
      CACHE_TTL.CATEGORIES,
    );
  }

  async getLowStock(tenantId: string) {
    const cacheKey = CACHE_KEYS.PRODUCT_LOW_STOCK(tenantId);

    return this.redis.getOrSet(
      cacheKey,
      async () => {
        const products = await this.prisma.product.findMany({
          where: {
            tenantId,
            trackStock: true,
            isActive: true,
          },
          select: {
            id: true,
            name: true,
            stock: true,
            minStock: true,
            unit: true,
          },
        });

        const lowStockProducts = products.filter(
          (p) => (p.stock ?? 0) <= (p.minStock ?? 0),
        );

        return {
          count: lowStockProducts.length,
          products: lowStockProducts,
        };
      },
      CACHE_TTL.LOW_STOCK,
    );
  }

  async findOne(tenantId: string, productId: string) {
    const product = await this.prisma.product.findFirst({
      where: { id: productId, tenantId },
    });

    if (!product) {
      throw new NotFoundException('Produk tidak ditemukan');
    }

    return product;
  }

  // ==========================================
  // ðŸš€ UPDATE - dengan SEO reindexing
  // ==========================================
  async update(tenantId: string, productId: string, dto: UpdateProductDto) {
    const existing = await this.prisma.product.findFirst({
      where: { id: productId, tenantId },
      select: { id: true, name: true, slug: true, sku: true },
    });

    if (!existing) {
      throw new NotFoundException('Produk tidak ditemukan');
    }

    if (dto.sku && dto.sku !== existing.sku) {
      const existingSku = await this.prisma.product.findFirst({
        where: { tenantId, sku: dto.sku, id: { not: productId } },
      });

      if (existingSku) {
        throw new ConflictException(`SKU "${dto.sku}" sudah digunakan`);
      }
    }

    let slug = existing.slug;
    if (dto.name && dto.name !== existing.name) {
      const baseSlug = this.generateSlug(dto.name);
      slug = await this.ensureUniqueSlug(tenantId, baseSlug, productId);
    }

    const product = await this.prisma.product.update({
      where: { id: productId },
      data: {
        name: dto.name,
        slug: dto.name ? slug : undefined,
        description: dto.description,
        category: dto.category,
        sku: dto.sku,
        price: dto.price,
        comparePrice: dto.comparePrice,
        costPrice: dto.costPrice,
        stock: dto.stock,
        minStock: dto.minStock,
        trackStock: dto.trackStock,
        unit: dto.unit,
        images: dto.images,
        metadata: dto.metadata,
        isActive: dto.isActive,
        isFeatured: dto.isFeatured,
      },
    });

    const tenant = await this.prisma.tenant.findUnique({
      where: { id: tenantId },
      select: { slug: true },
    });

    await this.redis.invalidateAllProductCaches(tenantId, tenant?.slug);

    // ðŸš€ SEO: Reindex updated product
    if (tenant) {
      this.seoService
        .onProductUpdated(tenant.slug, product.id, product.slug ?? undefined)
        .catch((error) => {
          console.error('[SEO] Failed to reindex product:', error.message);
        });
    }
    return {
      message: 'Produk berhasil diupdate',
      product,
    };
  }

  async updateStock(tenantId: string, productId: string, dto: UpdateStockDto) {
    const existing = await this.prisma.product.findFirst({
      where: { id: productId, tenantId },
      select: { id: true, name: true, stock: true, trackStock: true },
    });

    if (!existing) {
      throw new NotFoundException('Produk tidak ditemukan');
    }

    if (!existing.trackStock) {
      throw new BadRequestException(
        'Produk ini tidak menggunakan tracking stok',
      );
    }

    const newStock = (existing.stock ?? 0) + dto.quantity;

    if (newStock < 0) {
      throw new BadRequestException(
        `Stok tidak mencukupi. Stok saat ini: ${existing.stock}`,
      );
    }

    const product = await this.prisma.product.update({
      where: { id: productId },
      data: { stock: newStock },
      select: { id: true, name: true, stock: true, minStock: true },
    });

    const tenant = await this.prisma.tenant.findUnique({
      where: { id: tenantId },
      select: { slug: true },
    });

    await this.redis.invalidateAllProductCaches(tenantId, tenant?.slug);

    return {
      message:
        dto.quantity > 0
          ? `Stok berhasil ditambah ${dto.quantity}`
          : `Stok berhasil dikurangi ${Math.abs(dto.quantity)}`,
      product,
      previousStock: existing.stock,
      adjustment: dto.quantity,
      reason: dto.reason,
    };
  }

  async toggleActive(tenantId: string, productId: string) {
    const existing = await this.prisma.product.findFirst({
      where: { id: productId, tenantId },
      select: { id: true, name: true, isActive: true, slug: true },
    });

    if (!existing) {
      throw new NotFoundException('Produk tidak ditemukan');
    }

    const product = await this.prisma.product.update({
      where: { id: productId },
      data: { isActive: !existing.isActive },
      select: { id: true, name: true, isActive: true },
    });

    const tenant = await this.prisma.tenant.findUnique({
      where: { id: tenantId },
      select: { slug: true },
    });

    await this.redis.invalidateAllProductCaches(tenantId, tenant?.slug);

    return {
      message: product.isActive
        ? 'Produk berhasil diaktifkan'
        : 'Produk berhasil dinonaktifkan',
      product,
    };
  }

  // ==========================================
  // ðŸš€ REMOVE - dengan SEO notification
  // ==========================================
  async remove(tenantId: string, productId: string) {
    const existing = await this.prisma.product.findFirst({
      where: { id: productId, tenantId },
      select: { id: true, slug: true },
    });

    if (!existing) {
      throw new NotFoundException('Produk tidak ditemukan');
    }

    const tenant = await this.prisma.tenant.findUnique({
      where: { id: tenantId },
      select: { slug: true },
    });

    await this.prisma.product.delete({ where: { id: productId } });

    await this.redis.invalidateAllProductCaches(tenantId, tenant?.slug);

    // ðŸš€ SEO: Notify search engines about deleted product
    if (tenant) {
      this.seoService.onProductDeleted(tenant.slug).catch((error) => {
        console.error(
          '[SEO] Failed to notify product deletion:',
          error.message,
        );
      });
    }

    return {
      message: 'Produk berhasil dihapus',
    };
  }

  // ==========================================
  // ðŸš€ BULK DELETE - dengan SEO notification
  // ==========================================
  async bulkDelete(tenantId: string, ids: string[]) {
    const products = await this.prisma.product.findMany({
      where: { id: { in: ids }, tenantId },
      select: { id: true },
    });

    if (products.length === 0) {
      throw new NotFoundException('Tidak ada produk yang ditemukan');
    }

    const validIds = products.map((p) => p.id);

    const result = await this.prisma.product.deleteMany({
      where: { id: { in: validIds }, tenantId },
    });

    const tenant = await this.prisma.tenant.findUnique({
      where: { id: tenantId },
      select: { slug: true },
    });

    await this.redis.invalidateAllProductCaches(tenantId, tenant?.slug);

    // ðŸš€ SEO: Notify search engines about bulk deletion
    if (tenant) {
      this.seoService.onProductDeleted(tenant.slug).catch((error) => {
        console.error(
          '[SEO] Failed to notify bulk product deletion:',
          error.message,
        );
      });
    }

    return {
      message: `${result.count} produk berhasil dihapus`,
      count: result.count,
    };
  }
}



================================================================================
FILE: src/products/dto/index.ts
================================================================================

export * from './create-product.dto';
export * from './update-product.dto';
export * from './query-product.dto';
export * from './update-stock.dto';
export * from './bulk-delete.dto';



================================================================================
FILE: src/products/dto/create-product.dto.ts
================================================================================

import {
  IsString,
  IsNotEmpty,
  IsOptional,
  IsNumber,
  IsBoolean,
  IsArray,
  IsObject,
  Min,
  MaxLength,
} from 'class-validator';
import { Type } from 'class-transformer';

export class CreateProductDto {
  @IsString()
  @IsNotEmpty({ message: 'Nama produk tidak boleh kosong' })
  @MaxLength(200, { message: 'Nama produk maksimal 200 karakter' })
  name: string;

  @IsOptional()
  @IsString()
  @MaxLength(1000, { message: 'Deskripsi maksimal 1000 karakter' })
  description?: string;

  @IsOptional()
  @IsString()
  @MaxLength(100, { message: 'Kategori maksimal 100 karakter' })
  category?: string;

  @IsOptional()
  @IsString()
  @MaxLength(50, { message: 'SKU maksimal 50 karakter' })
  sku?: string;

  @IsNumber({}, { message: 'Harga harus berupa angka' })
  @Min(0, { message: 'Harga tidak boleh negatif' })
  @Type(() => Number)
  price: number;

  @IsOptional()
  @IsNumber({}, { message: 'Harga coret harus berupa angka' })
  @Min(0, { message: 'Harga coret tidak boleh negatif' })
  @Type(() => Number)
  comparePrice?: number;

  @IsOptional()
  @IsNumber({}, { message: 'Harga modal harus berupa angka' })
  @Min(0, { message: 'Harga modal tidak boleh negatif' })
  @Type(() => Number)
  costPrice?: number;

  @IsOptional()
  @IsNumber({}, { message: 'Stok harus berupa angka' })
  @Min(0, { message: 'Stok tidak boleh negatif' })
  @Type(() => Number)
  stock?: number;

  @IsOptional()
  @IsNumber({}, { message: 'Stok minimum harus berupa angka' })
  @Min(0, { message: 'Stok minimum tidak boleh negatif' })
  @Type(() => Number)
  minStock?: number;

  @IsOptional()
  @IsBoolean()
  trackStock?: boolean;

  @IsOptional()
  @IsString()
  @MaxLength(20, { message: 'Satuan maksimal 20 karakter' })
  unit?: string;

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  images?: string[];

  @IsOptional()
  @IsObject()
  metadata?: Record<string, any>;

  @IsOptional()
  @IsBoolean()
  isActive?: boolean;

  @IsOptional()
  @IsBoolean()
  isFeatured?: boolean;
}



================================================================================
FILE: src/products/dto/update-product.dto.ts
================================================================================

import { PartialType } from '@nestjs/mapped-types';
import { CreateProductDto } from './create-product.dto';

export class UpdateProductDto extends PartialType(CreateProductDto) {}



================================================================================
FILE: src/products/dto/update-stock.dto.ts
================================================================================

import { IsNumber, IsNotEmpty, IsOptional, IsString } from 'class-validator';
import { Type } from 'class-transformer';

export class UpdateStockDto {
  @IsNumber({}, { message: 'Jumlah harus berupa angka' })
  @IsNotEmpty({ message: 'Jumlah tidak boleh kosong' })
  @Type(() => Number)
  quantity: number; // Positive = add, Negative = subtract

  @IsOptional()
  @IsString()
  reason?: string; // "Restok", "Penjualan", "Rusak", etc.
}



================================================================================
FILE: src/products/dto/bulk-delete.dto.ts
================================================================================

import { IsArray, IsString, ArrayMinSize, ArrayMaxSize } from 'class-validator';

export class BulkDeleteDto {
  @IsArray()
  @IsString({ each: true })
  @ArrayMinSize(1, { message: 'Minimal 1 product ID' })
  @ArrayMaxSize(50, { message: 'Maksimal 50 products per request' })
  ids: string[];
}



================================================================================
FILE: src/products/dto/query-product.dto.ts
================================================================================

import {
  IsOptional,
  IsString,
  IsBoolean,
  IsNumber,
  Min,
} from 'class-validator';
import { Transform, Type } from 'class-transformer';

export class QueryProductDto {
  @IsOptional()
  @IsString()
  search?: string;

  @IsOptional()
  @IsString()
  category?: string;

  @IsOptional()
  @Transform(({ value }) => value === 'true' || value === true)
  @IsBoolean()
  isActive?: boolean;

  @IsOptional()
  @Transform(({ value }) => value === 'true' || value === true)
  @IsBoolean()
  isFeatured?: boolean;

  @IsOptional()
  @Transform(({ value }) => value === 'true' || value === true)
  @IsBoolean()
  lowStock?: boolean;

  @IsOptional()
  @IsString()
  sortBy?: 'name' | 'price' | 'stock' | 'createdAt' | 'updatedAt';

  @IsOptional()
  @IsString()
  sortOrder?: 'asc' | 'desc';

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  @Min(1)
  page?: number = 1;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  @Min(1)
  limit?: number = 20;
}



================================================================================
FILE: src/redis/redis.module.ts
================================================================================

import { Global, Module } from '@nestjs/common';
import { RedisService } from './redis.service';

@Global()
@Module({
  providers: [RedisService],
  exports: [RedisService],
})
export class RedisModule {}



================================================================================
FILE: src/redis/redis.service.ts
================================================================================

import { Injectable, OnModuleDestroy, Logger } from '@nestjs/common';
import { Redis } from '@upstash/redis';

// ==========================================
// CACHE TTL CONSTANTS (in seconds)
// ==========================================
export const CACHE_TTL = {
  // Short-lived (frequently changing)
  DASHBOARD_STATS: 60, // 1 minute
  RECENT_ORDERS: 30, // 30 seconds
  LOW_STOCK: 120, // 2 minutes

  // Medium-lived
  PRODUCT_LIST: 300, // 5 minutes
  PRODUCT_DETAIL: 600, // 10 minutes
  CUSTOMER_LIST: 300, // 5 minutes
  ORDER_LIST: 120, // 2 minutes

  // Long-lived (rarely changing)
  TENANT_PUBLIC: 1800, // 30 minutes
  TENANT_PRIVATE: 900, // 15 minutes
  CATEGORIES: 3600, // 1 hour
  SITEMAP: 3600, // 1 hour
} as const;

// ==========================================
// CACHE KEY PREFIXES
// ==========================================
export const CACHE_KEYS = {
  // Tenant related
  TENANT_SLUG: (slug: string) => `tenant:slug:${slug}`,
  TENANT_ID: (id: string) => `tenant:id:${id}`,
  TENANT_STATS: (id: string) => `tenant:stats:${id}`,
  TENANT_PRODUCTS_PUBLIC: (slug: string) => `tenant:products:public:${slug}`,

  // Product related
  PRODUCT_LIST: (tenantId: string, hash: string) =>
    `products:list:${tenantId}:${hash}`,
  PRODUCT_DETAIL: (id: string) => `products:detail:${id}`,
  PRODUCT_BY_SLUG: (tenantSlug: string, productSlug: string) =>
    `products:slug:${tenantSlug}:${productSlug}`,
  PRODUCT_CATEGORIES: (tenantId: string) => `products:categories:${tenantId}`,
  PRODUCT_LOW_STOCK: (tenantId: string) => `products:lowstock:${tenantId}`,

  // Customer related
  CUSTOMER_LIST: (tenantId: string, hash: string) =>
    `customers:list:${tenantId}:${hash}`,

  // Order related
  ORDER_LIST: (tenantId: string, hash: string) =>
    `orders:list:${tenantId}:${hash}`,

  // Sitemap
  SITEMAP_TENANTS: (page: number) => `sitemap:tenants:${page}`,
  SITEMAP_PRODUCTS: (page: number) => `sitemap:products:${page}`,
  SITEMAP_STATS: () => `sitemap:stats`,
} as const;

@Injectable()
export class RedisService implements OnModuleDestroy {
  private readonly redis: Redis | null = null;
  private readonly logger = new Logger(RedisService.name);
  private readonly isEnabled: boolean;

  constructor() {
    const url = process.env.UPSTASH_REDIS_REST_URL;
    const token = process.env.UPSTASH_REDIS_REST_TOKEN;

    if (url && token) {
      this.redis = new Redis({ url, token });
      this.isEnabled = true;
      this.logger.log('âœ… Redis (Upstash) connected');
    } else {
      this.isEnabled = false;
      this.logger.warn('âš ï¸ Redis not configured - caching disabled');
    }
  }

  onModuleDestroy(): void {
    this.logger.log('Redis service destroyed');
  }

  // ==========================================
  // CORE CACHE METHODS
  // ==========================================

  /**
   * Get cached value
   */
  async get<T>(key: string): Promise<T | null> {
    if (!this.isEnabled || !this.redis) return null;

    try {
      const data = await this.redis.get<T>(key);
      if (data) {
        this.logger.debug(`Cache HIT: ${key}`);
      }
      return data;
    } catch (error) {
      this.logger.error(`Cache GET error: ${key}`, error);
      return null;
    }
  }

  /**
   * Set cached value with TTL
   */
  async set<T>(key: string, value: T, ttlSeconds: number): Promise<void> {
    if (!this.isEnabled || !this.redis) return;

    try {
      await this.redis.set(key, value, { ex: ttlSeconds });
      this.logger.debug(`Cache SET: ${key} (TTL: ${ttlSeconds}s)`);
    } catch (error) {
      this.logger.error(`Cache SET error: ${key}`, error);
    }
  }

  /**
   * Delete cached value
   */
  async del(key: string): Promise<void> {
    if (!this.isEnabled || !this.redis) return;

    try {
      await this.redis.del(key);
      this.logger.debug(`Cache DEL: ${key}`);
    } catch (error) {
      this.logger.error(`Cache DEL error: ${key}`, error);
    }
  }

  // ==========================================
  // ðŸ”¥ NEW: DELETE BY PATTERN
  // ==========================================

  /**
   * Delete all keys matching a pattern
   * Uses SCAN for production safety
   */
  async delByPattern(pattern: string): Promise<number> {
    if (!this.isEnabled || !this.redis) return 0;

    try {
      // Use KEYS command (Upstash supports it)
      const keys = await this.redis.keys(pattern);

      if (!keys || keys.length === 0) {
        this.logger.debug(`Cache DEL pattern: ${pattern} (0 keys)`);
        return 0;
      }

      // Delete all matching keys
      await Promise.all(keys.map((key) => this.redis!.del(key)));

      this.logger.log(`Cache DEL pattern: ${pattern} (${keys.length} keys)`);
      return keys.length;
    } catch (error) {
      this.logger.error(`Cache delByPattern error: ${pattern}`, error);
      return 0;
    }
  }

  /**
   * ðŸ”¥ NEW: Invalidate ALL product-related caches for a tenant
   * This is the nuclear option - clears everything related to products
   */
  async invalidateAllProductCaches(
    tenantId: string,
    tenantSlug?: string,
  ): Promise<void> {
    if (!this.isEnabled || !this.redis) return;

    this.logger.log(
      `ðŸ”¥ Invalidating ALL product caches for tenant: ${tenantId}`,
    );

    // Delete by specific keys first
    const specificKeys = [
      CACHE_KEYS.PRODUCT_CATEGORIES(tenantId),
      CACHE_KEYS.PRODUCT_LOW_STOCK(tenantId),
      CACHE_KEYS.TENANT_STATS(tenantId),
    ];

    if (tenantSlug) {
      specificKeys.push(CACHE_KEYS.TENANT_PRODUCTS_PUBLIC(tenantSlug));
    }

    await Promise.all(specificKeys.map((key) => this.del(key)));

    // Delete by patterns (this catches all list queries with different hashes)
    const patterns = [`products:list:${tenantId}:*`, `products:detail:*`];

    if (tenantSlug) {
      patterns.push(`store:products:${tenantSlug}:*`);
      patterns.push(`store:product:${tenantSlug}:*`);
      patterns.push(`products:slug:${tenantSlug}:*`);
    }

    await Promise.all(patterns.map((p) => this.delByPattern(p)));

    this.logger.log(
      `âœ… All product caches invalidated for tenant: ${tenantId}`,
    );
  }

  // ==========================================
  // CACHE-ASIDE PATTERN
  // ==========================================

  /**
   * Get from cache or fetch from source
   */
  async getOrSet<T>(
    key: string,
    fetcher: () => Promise<T>,
    ttlSeconds: number,
  ): Promise<T> {
    const cached = await this.get<T>(key);
    if (cached !== null) {
      return cached;
    }

    const data = await fetcher();
    await this.set(key, data, ttlSeconds);

    return data;
  }

  // ==========================================
  // INVALIDATION HELPERS
  // ==========================================

  /**
   * Invalidate all cache for a tenant
   */
  async invalidateTenant(tenantId: string, slug?: string): Promise<void> {
    const keys = [
      CACHE_KEYS.TENANT_ID(tenantId),
      CACHE_KEYS.TENANT_STATS(tenantId),
      CACHE_KEYS.PRODUCT_CATEGORIES(tenantId),
      CACHE_KEYS.PRODUCT_LOW_STOCK(tenantId),
    ];

    if (slug) {
      keys.push(CACHE_KEYS.TENANT_SLUG(slug));
      keys.push(CACHE_KEYS.TENANT_PRODUCTS_PUBLIC(slug));
    }

    await Promise.all(keys.map((key) => this.del(key)));
  }

  /**
   * Invalidate single product cache
   */
  async invalidateProduct(
    productId: string,
    tenantId: string,
    tenantSlug?: string,
    productSlug?: string,
  ): Promise<void> {
    const keys = [
      CACHE_KEYS.PRODUCT_DETAIL(productId),
      CACHE_KEYS.PRODUCT_CATEGORIES(tenantId),
      CACHE_KEYS.PRODUCT_LOW_STOCK(tenantId),
    ];

    if (tenantSlug) {
      keys.push(CACHE_KEYS.TENANT_PRODUCTS_PUBLIC(tenantSlug));
      if (productSlug) {
        keys.push(CACHE_KEYS.PRODUCT_BY_SLUG(tenantSlug, productSlug));
      }
    }

    await Promise.all(keys.map((key) => this.del(key)));
  }

  /**
   * Invalidate dashboard stats
   */
  async invalidateStats(tenantId: string): Promise<void> {
    await this.del(CACHE_KEYS.TENANT_STATS(tenantId));
  }

  // ==========================================
  // UTILITY
  // ==========================================

  /**
   * Create a hash from query parameters for cache key
   */
  hashQuery(params: Record<string, unknown>): string {
    const sorted = Object.keys(params)
      .sort()
      .reduce(
        (acc, key) => {
          if (params[key] !== undefined && params[key] !== null) {
            acc[key] = params[key];
          }
          return acc;
        },
        {} as Record<string, unknown>,
      );

    return Buffer.from(JSON.stringify(sorted)).toString('base64').slice(0, 16);
  }

  // ==========================================
  // HEALTH CHECK
  // ==========================================

  async healthCheck(): Promise<{ status: string; latency?: number }> {
    if (!this.isEnabled || !this.redis) {
      return { status: 'disabled' };
    }

    try {
      const start = Date.now();
      await this.redis.ping();
      const latency = Date.now() - start;
      return { status: 'connected', latency };
    } catch {
      return { status: 'error' };
    }
  }
}



================================================================================
FILE: src/redis/index.ts
================================================================================

export * from './redis.module';
export * from './redis.service';



================================================================================
FILE: src/seo/seo.module.ts
================================================================================

import { Module } from '@nestjs/common';
import { HttpModule } from '@nestjs/axios';
import { ConfigModule } from '@nestjs/config';

// Controller
import { SeoController } from './seo.controller';

// Main Orchestrator
import { SeoService } from './seo.service';

// Individual Indexing Services
import { GoogleIndexingService } from './services/google-indexing.service';
import { IndexNowService } from './services/index-now.service';
import { GooglePingService } from './services/google-ping.service';

// Key & Quota Management
import { KeyManagerService } from './managers/key-manager.service';
import { QuotaTrackerService } from './managers/quota-tracker.service';

// ==========================================
// SEO MODULE
// Combines all indexing engines into one powerful module
// ==========================================

@Module({
  imports: [
    HttpModule.register({
      timeout: 15000,
      maxRedirects: 3,
    }),
    ConfigModule,
  ],
  controllers: [SeoController],
  providers: [
    // Main orchestrator service
    SeoService,

    // Individual indexing services
    GoogleIndexingService,
    IndexNowService,
    GooglePingService,

    // Key rotation & quota management
    KeyManagerService,
    QuotaTrackerService,
  ],
  exports: [SeoService],
})
export class SeoModule {}



================================================================================
FILE: src/seo/seo.controller.ts
================================================================================

import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  UseGuards,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { SeoService } from './seo.service';
import { JwtAuthGuard } from '../common/guards/jwt-auth.guard';
import { BatchReindexTenantsDto, IndexUrlDto } from './dto';

// ==========================================
// SEO CONTROLLER
// API endpoints for SEO operations
// ==========================================

@Controller('seo')
export class SeoController {
  constructor(private readonly seoService: SeoService) {}

  // ==========================================
  // PUBLIC: Get SEO service status
  // GET /api/seo/status
  // ==========================================

  @Get('status')
  async getStatus() {
    return this.seoService.getStatus();
  }

  // ==========================================
  // PUBLIC: Get detailed stats
  // GET /api/seo/stats
  // ==========================================

  @Get('stats')
  async getStats() {
    return this.seoService.getDetailedStats();
  }

  // ==========================================
  // PROTECTED: Manual reindex single tenant
  // POST /api/seo/reindex/:slug
  // ==========================================

  @Post('reindex/:slug')
  @UseGuards(JwtAuthGuard)
  @HttpCode(HttpStatus.OK)
  async reindexTenant(@Param('slug') slug: string) {
    const result = await this.seoService.onTenantUpdated(slug);

    return {
      message: `Tenant "${slug}" submitted for reindexing`,
      ...result,
    };
  }

  // ==========================================
  // PROTECTED: Batch reindex multiple tenants
  // POST /api/seo/reindex/batch
  // ==========================================

  @Post('reindex/batch')
  @UseGuards(JwtAuthGuard)
  @HttpCode(HttpStatus.OK)
  async batchReindex(@Body() dto: BatchReindexTenantsDto) {
    const result = await this.seoService.batchReindex(dto.slugs);

    return {
      message: `Batch reindex completed: ${result.successful}/${result.total} successful`,
      ...result,
    };
  }

  // ==========================================
  // PROTECTED: Index single URL
  // POST /api/seo/index-url
  // ==========================================

  @Post('index-url')
  @UseGuards(JwtAuthGuard)
  @HttpCode(HttpStatus.OK)
  async indexUrl(@Body() dto: IndexUrlDto) {
    // Extract slug from URL
    const urlObj = new URL(dto.url);
    const hostParts = urlObj.hostname.split('.');
    const slug = hostParts[0];

    // Determine if it's a product or tenant page
    if (
      urlObj.pathname.includes('/p/') ||
      urlObj.pathname.includes('/product/')
    ) {
      const result = await this.seoService.onProductCreated(
        slug,
        'manual',
        urlObj.pathname.split('/').pop(),
      );
      return { message: 'Product URL submitted for indexing', ...result };
    }

    const result = await this.seoService.onTenantUpdated(slug);
    return { message: 'Tenant URL submitted for indexing', ...result };
  }
}



================================================================================
FILE: src/seo/seo.service.ts
================================================================================

import { Injectable, Logger } from '@nestjs/common';
import { GoogleIndexingService } from './services/google-indexing.service';
import { IndexNowService } from './services/index-now.service';
import { GooglePingService } from './services/google-ping.service';
import { QuotaTrackerService } from './managers/quota-tracker.service';
import {
  SeoIndexResult,
  SeoServiceStatus,
  ProductIndexResult,
} from './interfaces';

// ==========================================
// SEO SERVICE - MAIN ORCHESTRATOR
// Combines all indexing engines for maximum coverage
// Fire-and-forget pattern for async indexing
// ==========================================

@Injectable()
export class SeoService {
  private readonly logger = new Logger(SeoService.name);

  constructor(
    private readonly googleIndexing: GoogleIndexingService,
    private readonly indexNow: IndexNowService,
    private readonly googlePing: GooglePingService,
    private readonly quotaTracker: QuotaTrackerService,
  ) {
    this.logger.log('ðŸš€ SEO Service initialized - All engines ready');
  }

  // ==========================================
  // ðŸš€ ON TENANT CREATED
  // Maximum power: use ALL indexing methods!
  // ==========================================

  async onTenantCreated(slug: string): Promise<SeoIndexResult> {
    this.logger.log(`ðŸš€ FULL INDEX: New tenant "${slug}"`);

    const timestamp = new Date().toISOString();

    try {
      // Fire all engines in parallel for speed
      const [googleResult, indexNowResult, pingResult] = await Promise.all([
        this.googleIndexing.submitTenantPages(slug),
        this.indexNow.submitTenantPages(slug),
        this.googlePing.pingTenantSitemap(slug),
      ]);

      // Also ping platform sitemap (fire-and-forget)
      this.googlePing.pingPlatformSitemap().catch(() => {});

      // Track tenant indexed
      await this.quotaTracker.trackTenantIndexed(slug);

      // Get current quota stats
      const quotaStats = this.googleIndexing.getQuotaStats();

      const result: SeoIndexResult = {
        tenant: slug,
        googleIndexing: {
          success: googleResult.success,
          urlsSubmitted: googleResult.results.filter((r) => r.success).length,
          quotaRemaining: quotaStats.remainingToday,
          results: googleResult.results,
        },
        indexNow: {
          success: indexNowResult.success,
          urlsSubmitted: indexNowResult.urls.length,
        },
        googlePing: {
          success: pingResult.success,
          status: pingResult.status,
        },
        timestamp,
      };

      this.logger.log(`âœ… Tenant "${slug}" indexed successfully`, {
        google: result.googleIndexing.success,
        indexNow: result.indexNow.success,
        ping: result.googlePing.success,
      });

      return result;
    } catch (error: unknown) {
      const errorMessage =
        error instanceof Error ? error.message : 'Unknown error';
      this.logger.error(`âŒ Failed to index tenant "${slug}": ${errorMessage}`);

      return {
        tenant: slug,
        googleIndexing: { success: false, urlsSubmitted: 0, quotaRemaining: 0 },
        indexNow: { success: false, urlsSubmitted: 0 },
        googlePing: { success: false },
        timestamp,
      };
    }
  }

  // ==========================================
  // ðŸ”„ ON TENANT UPDATED
  // Re-index when tenant updates profile/settings
  // ==========================================

  async onTenantUpdated(slug: string): Promise<SeoIndexResult> {
    this.logger.log(`ðŸ”„ RE-INDEX: Tenant "${slug}" updated`);
    return this.onTenantCreated(slug);
  }

  // ==========================================
  // ðŸ“¦ ON PRODUCT CREATED
  // Index new product page
  // ==========================================

  async onProductCreated(
    tenantSlug: string,
    productId: string,
    productSlug?: string,
  ): Promise<ProductIndexResult> {
    this.logger.log(
      `ðŸ“¦ INDEX: New product "${productSlug || productId}" for "${tenantSlug}"`,
    );

    const baseUrl = `https://${tenantSlug}.fibidy.com`;
    const productUrl = productSlug
      ? `${baseUrl}/p/${productSlug}`
      : `${baseUrl}/product/${productId}`;

    try {
      const [googleResult, indexNowResult, pingResult] = await Promise.all([
        this.googleIndexing.submitUrl(productUrl),
        this.indexNow.submitUrls([productUrl, `${baseUrl}/products`]),
        this.googlePing.pingTenantSitemap(tenantSlug),
      ]);

      // Track product indexed
      await this.quotaTracker.trackProductIndexed();

      const success =
        googleResult.success || indexNowResult.success || pingResult.success;

      this.logger.log(`âœ… Product indexed: ${success ? 'SUCCESS' : 'PARTIAL'}`);

      return {
        success,
        productUrl,
        googleIndexing: googleResult,
        indexNow: {
          success: indexNowResult.success,
          urlsSubmitted: indexNowResult.submittedUrls,
        },
        googlePing: {
          success: pingResult.success,
        },
      };
    } catch (error: unknown) {
      const errorMessage =
        error instanceof Error ? error.message : 'Unknown error';
      this.logger.error(`âŒ Failed to index product: ${errorMessage}`);

      return {
        success: false,
        productUrl,
      };
    }
  }

  // ==========================================
  // ðŸ“ ON PRODUCT UPDATED
  // Re-index when product is modified
  // ==========================================

  async onProductUpdated(
    tenantSlug: string,
    productId: string,
    productSlug?: string,
  ): Promise<ProductIndexResult> {
    this.logger.log(
      `ðŸ“ RE-INDEX: Product "${productSlug || productId}" updated`,
    );
    return this.onProductCreated(tenantSlug, productId, productSlug);
  }

  // ==========================================
  // ðŸ—‘ï¸ ON PRODUCT DELETED
  // Refresh sitemap after deletion
  // ==========================================

  async onProductDeleted(tenantSlug: string): Promise<{ success: boolean }> {
    this.logger.log(`ðŸ—‘ï¸ REFRESH: Product deleted from "${tenantSlug}"`);

    try {
      const result = await this.googlePing.pingTenantSitemap(tenantSlug);
      return { success: result.success };
    } catch (error: unknown) {
      const errorMessage =
        error instanceof Error ? error.message : 'Unknown error';
      this.logger.error(`Failed to refresh sitemap: ${errorMessage}`);
      return { success: false };
    }
  }

  // ==========================================
  // ðŸ“Š BATCH REINDEX
  // Reindex multiple tenants (for maintenance)
  // ==========================================

  async batchReindex(slugs: string[]): Promise<{
    total: number;
    successful: number;
    failed: string[];
    results: SeoIndexResult[];
  }> {
    this.logger.log(`ðŸ“Š BATCH REINDEX: ${slugs.length} tenants`);

    const results: SeoIndexResult[] = [];
    const failed: string[] = [];
    let successful = 0;

    // Process in batches of 10 to avoid overwhelming
    const batchSize = 10;

    for (let i = 0; i < slugs.length; i += batchSize) {
      const batch = slugs.slice(i, i + batchSize);

      const batchResults = await Promise.all(
        batch.map(async (slug) => {
          try {
            const result = await this.onTenantUpdated(slug);
            return { slug, result, error: null };
          } catch (error: unknown) {
            const errorMessage =
              error instanceof Error ? error.message : 'Unknown error';
            return { slug, result: null, error: errorMessage };
          }
        }),
      );

      for (const { slug, result, error } of batchResults) {
        if (
          result &&
          (result.googleIndexing.success || result.indexNow.success)
        ) {
          successful++;
          results.push(result);
        } else {
          failed.push(slug);
          this.logger.warn(`Failed to reindex: ${slug} - ${error}`);
        }
      }

      // Delay between batches
      if (i + batchSize < slugs.length) {
        await this.delay(2000);
      }
    }

    // Ping platform sitemap at the end
    await this.googlePing.pingPlatformSitemap();

    this.logger.log(
      `âœ… Batch reindex complete: ${successful}/${slugs.length} successful`,
    );

    return {
      total: slugs.length,
      successful,
      failed,
      results,
    };
  }

  // ==========================================
  // ðŸ“Š GET SERVICE STATUS
  // ==========================================

  getStatus(): SeoServiceStatus {
    const quotaStats = this.googleIndexing.getQuotaStats();

    return {
      googleIndexing: {
        enabled: this.googleIndexing.isAvailable(),
        totalKeys: quotaStats.totalKeys,
        totalCapacity: quotaStats.totalCapacity,
        totalUsed: quotaStats.totalUsed,
        remainingToday: quotaStats.remainingToday,
      },
      indexNow: {
        enabled: this.indexNow.isServiceEnabled(),
      },
      googlePing: {
        enabled: true, // Always enabled
      },
      timestamp: new Date().toISOString(),
    };
  }

  // ==========================================
  // ðŸ“ˆ GET DETAILED STATS
  // ==========================================

  async getDetailedStats() {
    const status = this.getStatus();
    const quotaStats = this.googleIndexing.getQuotaStats();
    const summary = await this.quotaTracker.getSummary();

    return {
      status,
      keys: quotaStats.keys,
      today: summary.today,
      last7Days: summary.last7Days,
    };
  }

  // ==========================================
  // HELPERS
  // ==========================================

  private delay(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
}



================================================================================
FILE: src/seo/index.ts
================================================================================

// ==========================================
// SEO MODULE - BARREL EXPORT
// ==========================================

// Module
export * from './seo.module';

// Main Service (for external use)
export * from './seo.service';

// Individual Services
export * from './services';

// Managers
export * from './managers';

// DTOs
export * from './dto';

// Interfaces
export * from './interfaces';



================================================================================
FILE: src/seo/dto/index.ts
================================================================================

// ==========================================
// DTO - BARREL EXPORT
// ==========================================

export * from './index-url.dto';
export * from './batch-index.dto';



================================================================================
FILE: src/seo/dto/index-url.dto.ts
================================================================================

import { IsString, IsNotEmpty, IsUrl, IsOptional, IsIn } from 'class-validator';

// ==========================================
// INDEX URL DTO
// For single URL submission
// ==========================================

export class IndexUrlDto {
  @IsString()
  @IsNotEmpty({ message: 'URL tidak boleh kosong' })
  @IsUrl({}, { message: 'Format URL tidak valid' })
  url: string;

  @IsOptional()
  @IsString()
  @IsIn(['URL_UPDATED', 'URL_DELETED'], {
    message: 'Type harus URL_UPDATED atau URL_DELETED',
  })
  type?: 'URL_UPDATED' | 'URL_DELETED' = 'URL_UPDATED';
}



================================================================================
FILE: src/seo/dto/batch-index.dto.ts
================================================================================

import {
  IsArray,
  IsString,
  IsNotEmpty,
  ArrayMinSize,
  ArrayMaxSize,
  IsUrl,
} from 'class-validator';

// ==========================================
// BATCH INDEX DTO
// For bulk URL submission
// ==========================================

export class BatchIndexDto {
  @IsArray()
  @ArrayMinSize(1, { message: 'Minimal 1 URL' })
  @ArrayMaxSize(100, { message: 'Maksimal 100 URL per batch' })
  @IsString({ each: true })
  @IsUrl({}, { each: true, message: 'Semua URL harus valid' })
  urls: string[];
}

export class BatchReindexTenantsDto {
  @IsArray()
  @ArrayMinSize(1, { message: 'Minimal 1 slug' })
  @ArrayMaxSize(50, { message: 'Maksimal 50 tenants per batch' })
  @IsString({ each: true })
  @IsNotEmpty({ each: true })
  slugs: string[];
}



================================================================================
FILE: src/seo/interfaces/index.ts
================================================================================

// ==========================================
// INTERFACES - BARREL EXPORT
// ==========================================

export * from './api-key.interface';
export * from './seo-result.interface';



================================================================================
FILE: src/seo/interfaces/api-key.interface.ts
================================================================================

// ==========================================
// API KEY INTERFACE
// Type definitions for Google Indexing API keys
// ==========================================

export interface GoogleApiKeyConfig {
  /** Unique identifier for this key (e.g., key_1, key_2) */
  id: string;

  /** Google Cloud Project ID */
  projectId: string;

  /** Service Account Email */
  clientEmail: string;

  /** Private Key (PEM format) */
  privateKey: string;

  /** Daily quota limit (default: 200) */
  dailyQuota: number;

  /** Number of requests used today */
  usedToday: number;

  /** Date of last quota reset (YYYY-MM-DD) */
  lastReset: string;

  /** Whether this key is currently active */
  isActive: boolean;
}

export interface GoogleApiKeyInput {
  projectId?: string;
  project_id?: string;
  clientEmail?: string;
  client_email?: string;
  privateKey?: string;
  private_key?: string;
}

export interface KeyStats {
  totalKeys: number;
  totalCapacity: number;
  totalUsed: number;
  remainingToday: number;
  keys: Array<{
    id: string;
    used: number;
    remaining: number;
    isActive: boolean;
  }>;
}



================================================================================
FILE: src/seo/interfaces/seo-result.interface.ts
================================================================================

// ==========================================
// SEO RESULT INTERFACES
// Type definitions for indexing results
// ==========================================

/** Result from Google Indexing API submission */
export interface GoogleIndexingResult {
  url: string;
  success: boolean;
  keyUsed: string;
  response?: {
    urlNotificationMetadata?: {
      url?: string;
      latestUpdate?: {
        type?: string;
        notifyTime?: string;
      };
    };
  };
  error?: string;
}

/** Result from IndexNow submission */
export interface IndexNowResult {
  endpoint: string;
  status: number;
  success: boolean;
  error?: string;
}

/** Result from Google Sitemap Ping */
export interface GooglePingResult {
  sitemapUrl: string;
  success: boolean;
  status: number;
  error?: string;
}

/** Combined result from all SEO engines */
export interface SeoIndexResult {
  tenant: string;
  googleIndexing: {
    success: boolean;
    urlsSubmitted: number;
    quotaRemaining: number;
    results?: GoogleIndexingResult[];
  };
  indexNow: {
    success: boolean;
    urlsSubmitted: number;
    results?: IndexNowResult[];
  };
  googlePing: {
    success: boolean;
    status?: number;
  };
  timestamp: string;
}

/** Status response for SEO service */
export interface SeoServiceStatus {
  googleIndexing: {
    enabled: boolean;
    totalKeys: number;
    totalCapacity: number;
    totalUsed: number;
    remainingToday: number;
  };
  indexNow: {
    enabled: boolean;
  };
  googlePing: {
    enabled: boolean;
  };
  timestamp: string;
}

/** Product indexing result */
export interface ProductIndexResult {
  success: boolean;
  productUrl: string;
  googleIndexing?: GoogleIndexingResult;
  indexNow?: {
    success: boolean;
    urlsSubmitted: number;
  };
  googlePing?: {
    success: boolean;
  };
}



================================================================================
FILE: src/seo/managers/index.ts
================================================================================

// ==========================================
// MANAGERS - BARREL EXPORT
// ==========================================

export * from './key-manager.service';
export * from './quota-tracker.service';



================================================================================
FILE: src/seo/managers/key-manager.service.ts
================================================================================

import { Injectable, Logger, OnModuleInit } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { RedisService } from '../../redis/redis.service';
import { GoogleApiKeyConfig, GoogleApiKeyInput, KeyStats } from '../interfaces';

// ==========================================
// KEY MANAGER SERVICE
// Handles multi-key rotation for Google Indexing API
// Round-robin distribution across multiple API keys
// ==========================================

@Injectable()
export class KeyManagerService implements OnModuleInit {
  private readonly logger = new Logger(KeyManagerService.name);
  private keys: GoogleApiKeyConfig[] = [];
  private currentKeyIndex = 0;

  // Redis key prefix for quota tracking
  private readonly QUOTA_PREFIX = 'seo:quota:';
  private readonly DAILY_QUOTA = 200; // Google's limit per key

  constructor(
    private readonly configService: ConfigService,
    private readonly redis: RedisService,
  ) {}

  // ==========================================
  // INITIALIZATION
  // ==========================================
  async onModuleInit(): Promise<void> {
    this.loadKeys(); // Remove await
    await this.syncQuotasFromRedis();

    if (this.keys.length > 0) {
      this.logger.log(`âœ… Key Manager initialized`);
      this.logger.log(`ðŸ“Š Total keys: ${this.keys.length}`);
      this.logger.log(
        `ðŸ“Š Daily capacity: ${this.keys.length * this.DAILY_QUOTA} URLs`,
      );
    } else {
      this.logger.warn('âš ï¸ No Google Indexing API keys configured');
    }
  }

  // ==========================================
  // LOAD KEYS FROM ENVIRONMENT
  // ==========================================

  // ==========================================
  // LOAD KEYS FROM ENVIRONMENT
  // ==========================================

  private loadKeys(): void {
    const keysJson = this.configService.get<string>('GOOGLE_INDEXING_KEYS');

    if (!keysJson) {
      this.logger.warn('GOOGLE_INDEXING_KEYS not found in environment');
      return;
    }

    try {
      const parsedKeys: GoogleApiKeyInput[] = JSON.parse(keysJson);

      if (!Array.isArray(parsedKeys)) {
        throw new Error('GOOGLE_INDEXING_KEYS must be a JSON array');
      }

      this.keys = parsedKeys.map((key, index) => ({
        id: `key_${index + 1}`,
        projectId: key.projectId || key.project_id || '',
        clientEmail: key.clientEmail || key.client_email || '',
        privateKey: (key.privateKey || key.private_key || '').replace(
          /\\n/g,
          '\n',
        ),
        dailyQuota: this.DAILY_QUOTA,
        usedToday: 0,
        lastReset: this.getTodayDate(),
        isActive: true,
      }));

      // Validate keys
      this.keys = this.keys.filter((key) => {
        if (!key.clientEmail || !key.privateKey) {
          this.logger.warn(`Key ${key.id} is invalid (missing credentials)`);
          return false;
        }
        return true;
      });
    } catch (error) {
      this.logger.error('Failed to parse GOOGLE_INDEXING_KEYS:', error);
      this.keys = [];
    }
  }
  // ==========================================
  // SYNC QUOTAS FROM REDIS
  // ==========================================

  private async syncQuotasFromRedis(): Promise<void> {
    const today = this.getTodayDate();

    for (const key of this.keys) {
      const redisKey = `${this.QUOTA_PREFIX}${key.id}`;
      const storedData = await this.redis.get<{
        used: number;
        date: string;
      }>(redisKey);

      if (storedData && storedData.date === today) {
        key.usedToday = storedData.used;
      } else {
        // New day - reset quota
        key.usedToday = 0;
        key.lastReset = today;
      }
    }
  }

  // ==========================================
  // GET NEXT AVAILABLE KEY (Round Robin)
  // ==========================================

  async getNextAvailableKey(): Promise<GoogleApiKeyConfig | null> {
    if (this.keys.length === 0) {
      return null;
    }

    // Sync from Redis first
    await this.syncQuotasFromRedis();

    // Try each key starting from current index
    for (let i = 0; i < this.keys.length; i++) {
      const index = (this.currentKeyIndex + i) % this.keys.length;
      const key = this.keys[index];

      if (key.isActive && key.usedToday < key.dailyQuota) {
        // Move to next key for next request (round robin)
        this.currentKeyIndex = (index + 1) % this.keys.length;

        this.logger.debug(
          `Using ${key.id}: ${key.usedToday}/${key.dailyQuota}`,
        );
        return key;
      }
    }

    // All keys exhausted
    this.logger.warn('âš ï¸ All API keys quota exhausted for today');
    return null;
  }

  // ==========================================
  // INCREMENT KEY USAGE
  // ==========================================

  async incrementUsage(keyId: string): Promise<void> {
    const key = this.keys.find((k) => k.id === keyId);
    if (!key) {
      this.logger.warn(`Key ${keyId} not found`);
      return;
    }

    const today = this.getTodayDate();
    const redisKey = `${this.QUOTA_PREFIX}${keyId}`;

    // Increment usage
    key.usedToday += 1;
    key.lastReset = today;

    // Calculate TTL until midnight
    const ttlSeconds = this.getSecondsUntilMidnight();

    // Store in Redis
    await this.redis.set(
      redisKey,
      { used: key.usedToday, date: today },
      ttlSeconds,
    );

    this.logger.debug(`${keyId}: ${key.usedToday}/${key.dailyQuota} used`);
  }

  // ==========================================
  // MARK KEY AS FAILED (Temporary disable)
  // ==========================================

  markKeyAsFailed(keyId: string): void {
    const key = this.keys.find((k) => k.id === keyId);
    if (key) {
      key.isActive = false;
      this.logger.warn(`Key ${keyId} marked as inactive`);

      // Re-enable after 5 minutes
      setTimeout(
        () => {
          key.isActive = true;
          this.logger.log(`Key ${keyId} re-enabled`);
        },
        5 * 60 * 1000,
      );
    }
  }

  // ==========================================
  // GET STATISTICS
  // ==========================================

  getStats(): KeyStats {
    const totalUsed = this.keys.reduce((sum, k) => sum + k.usedToday, 0);
    const totalCapacity = this.keys.length * this.DAILY_QUOTA;

    return {
      totalKeys: this.keys.length,
      totalCapacity,
      totalUsed,
      remainingToday: totalCapacity - totalUsed,
      keys: this.keys.map((k) => ({
        id: k.id,
        used: k.usedToday,
        remaining: k.dailyQuota - k.usedToday,
        isActive: k.isActive,
      })),
    };
  }

  // ==========================================
  // CHECK IF ANY QUOTA AVAILABLE
  // ==========================================

  hasAvailableQuota(): boolean {
    return this.keys.some((k) => k.isActive && k.usedToday < k.dailyQuota);
  }

  // ==========================================
  // GET TOTAL REMAINING QUOTA
  // ==========================================

  getTotalRemainingQuota(): number {
    return this.keys.reduce((sum, k) => sum + (k.dailyQuota - k.usedToday), 0);
  }

  // ==========================================
  // HELPERS
  // ==========================================

  private getTodayDate(): string {
    return new Date().toISOString().split('T')[0];
  }

  private getSecondsUntilMidnight(): number {
    const now = new Date();
    const midnight = new Date(now);
    midnight.setHours(24, 0, 0, 0);
    return Math.floor((midnight.getTime() - now.getTime()) / 1000);
  }
}



================================================================================
FILE: src/seo/managers/quota-tracker.service.ts
================================================================================

import { Injectable, Logger } from '@nestjs/common';
import { RedisService } from '../../redis/redis.service';

// ==========================================
// QUOTA TRACKER SERVICE
// Tracks overall SEO engine usage and statistics
// ==========================================

// Export the interface
export interface DailyStats {
  date: string;
  googleIndexing: {
    submitted: number;
    success: number;
    failed: number;
  };
  indexNow: {
    submitted: number;
    success: number;
    failed: number;
  };
  googlePing: {
    submitted: number;
    success: number;
    failed: number;
  };
  tenants: {
    indexed: number;
    slugs: string[];
  };
  products: {
    indexed: number;
  };
}

@Injectable()
export class QuotaTrackerService {
  private readonly logger = new Logger(QuotaTrackerService.name);
  private readonly STATS_PREFIX = 'seo:stats:';
  private readonly STATS_TTL = 7 * 24 * 60 * 60; // 7 days

  constructor(private readonly redis: RedisService) {}

  // ==========================================
  // TRACK GOOGLE INDEXING RESULT
  // ==========================================

  async trackGoogleIndexing(success: boolean): Promise<void> {
    const stats = await this.getTodayStats();
    stats.googleIndexing.submitted += 1;
    if (success) {
      stats.googleIndexing.success += 1;
    } else {
      stats.googleIndexing.failed += 1;
    }
    await this.saveTodayStats(stats);
  }

  // ==========================================
  // TRACK INDEXNOW RESULT
  // ==========================================

  async trackIndexNow(success: boolean, urlCount: number = 1): Promise<void> {
    const stats = await this.getTodayStats();
    stats.indexNow.submitted += urlCount;
    if (success) {
      stats.indexNow.success += urlCount;
    } else {
      stats.indexNow.failed += urlCount;
    }
    await this.saveTodayStats(stats);
  }

  // ==========================================
  // TRACK GOOGLE PING RESULT
  // ==========================================

  async trackGooglePing(success: boolean): Promise<void> {
    const stats = await this.getTodayStats();
    stats.googlePing.submitted += 1;
    if (success) {
      stats.googlePing.success += 1;
    } else {
      stats.googlePing.failed += 1;
    }
    await this.saveTodayStats(stats);
  }

  // ==========================================
  // TRACK TENANT INDEXED
  // ==========================================

  async trackTenantIndexed(slug: string): Promise<void> {
    const stats = await this.getTodayStats();
    stats.tenants.indexed += 1;
    if (!stats.tenants.slugs.includes(slug)) {
      stats.tenants.slugs.push(slug);
    }
    await this.saveTodayStats(stats);
  }

  // ==========================================
  // TRACK PRODUCT INDEXED
  // ==========================================

  async trackProductIndexed(): Promise<void> {
    const stats = await this.getTodayStats();
    stats.products.indexed += 1;
    await this.saveTodayStats(stats);
  }

  // ==========================================
  // GET TODAY'S STATS
  // ==========================================

  async getTodayStats(): Promise<DailyStats> {
    const today = this.getTodayDate();
    const key = `${this.STATS_PREFIX}${today}`;

    const stored = await this.redis.get<DailyStats>(key);

    if (stored) {
      return stored;
    }

    // Return empty stats
    return this.createEmptyStats(today);
  }

  // ==========================================
  // GET STATS FOR DATE RANGE
  // ==========================================

  async getStatsRange(
    days: number = 7,
  ): Promise<{ date: string; stats: DailyStats }[]> {
    const results: { date: string; stats: DailyStats }[] = [];

    for (let i = 0; i < days; i++) {
      const date = this.getDateDaysAgo(i);
      const key = `${this.STATS_PREFIX}${date}`;
      const stats = await this.redis.get<DailyStats>(key);

      results.push({
        date,
        stats: stats || this.createEmptyStats(date),
      });
    }

    return results;
  }

  // ==========================================
  // GET SUMMARY
  // ==========================================

  async getSummary(): Promise<{
    today: DailyStats;
    last7Days: {
      totalSubmitted: number;
      totalSuccess: number;
      totalFailed: number;
      tenantsIndexed: number;
      productsIndexed: number;
    };
  }> {
    const today = await this.getTodayStats();
    const rangeStats = await this.getStatsRange(7);

    const last7Days = rangeStats.reduce(
      (acc, { stats }) => {
        acc.totalSubmitted +=
          stats.googleIndexing.submitted +
          stats.indexNow.submitted +
          stats.googlePing.submitted;
        acc.totalSuccess +=
          stats.googleIndexing.success +
          stats.indexNow.success +
          stats.googlePing.success;
        acc.totalFailed +=
          stats.googleIndexing.failed +
          stats.indexNow.failed +
          stats.googlePing.failed;
        acc.tenantsIndexed += stats.tenants.indexed;
        acc.productsIndexed += stats.products.indexed;
        return acc;
      },
      {
        totalSubmitted: 0,
        totalSuccess: 0,
        totalFailed: 0,
        tenantsIndexed: 0,
        productsIndexed: 0,
      },
    );

    return { today, last7Days };
  }

  // ==========================================
  // HELPERS
  // ==========================================

  private async saveTodayStats(stats: DailyStats): Promise<void> {
    const key = `${this.STATS_PREFIX}${stats.date}`;
    await this.redis.set(key, stats, this.STATS_TTL);
  }

  private createEmptyStats(date: string): DailyStats {
    return {
      date,
      googleIndexing: { submitted: 0, success: 0, failed: 0 },
      indexNow: { submitted: 0, success: 0, failed: 0 },
      googlePing: { submitted: 0, success: 0, failed: 0 },
      tenants: { indexed: 0, slugs: [] },
      products: { indexed: 0 },
    };
  }

  private getTodayDate(): string {
    return new Date().toISOString().split('T')[0];
  }

  private getDateDaysAgo(days: number): string {
    const date = new Date();
    date.setDate(date.getDate() - days);
    return date.toISOString().split('T')[0];
  }
}



================================================================================
FILE: src/seo/services/index.ts
================================================================================

// ==========================================
// SERVICES - BARREL EXPORT
// ==========================================

export * from './google-indexing.service';
export * from './index-now.service';
export * from './google-ping.service';



================================================================================
FILE: src/seo/services/index-now.service.ts
================================================================================

import { Injectable, Logger } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import { ConfigService } from '@nestjs/config';
import { QuotaTrackerService } from '../managers/quota-tracker.service';
import { IndexNowResult } from '../interfaces';

// ==========================================
// INDEXNOW SERVICE
// Push notifications to multiple search engines:
// - Bing
// - Yandex
// - Naver
// - Seznam
// ==========================================

interface IndexNowPayload {
  host: string;
  key: string;
  keyLocation: string;
  urlList: string[];
}

@Injectable()
export class IndexNowService {
  private readonly logger = new Logger(IndexNowService.name);
  private readonly apiKey: string;
  private readonly isEnabled: boolean;

  // All IndexNow-compatible endpoints
  private readonly endpoints = [
    'https://api.indexnow.org/indexnow', // Universal (shared by all)
    'https://www.bing.com/indexnow', // Bing
    'https://yandex.com/indexnow', // Yandex
  ];

  constructor(
    private readonly httpService: HttpService,
    private readonly configService: ConfigService,
    private readonly quotaTracker: QuotaTrackerService,
  ) {
    this.apiKey = this.configService.get<string>('INDEXNOW_API_KEY') || '';
    this.isEnabled = !!this.apiKey && this.apiKey.length >= 8;

    if (this.isEnabled) {
      this.logger.log('âœ… IndexNow service enabled');
      this.logger.log(`ðŸ“Š API Key: ${this.apiKey.substring(0, 4)}...`);
    } else {
      this.logger.warn('âš ï¸ IndexNow not configured (INDEXNOW_API_KEY missing)');
    }
  }

  // ==========================================
  // SUBMIT URLs TO ALL ENDPOINTS
  // ==========================================

  async submitUrls(urls: string[]): Promise<{
    success: boolean;
    results: IndexNowResult[];
    submittedUrls: number;
  }> {
    if (!this.isEnabled) {
      this.logger.debug('IndexNow disabled - skipping');
      return { success: false, results: [], submittedUrls: 0 };
    }

    if (!urls || urls.length === 0) {
      return { success: true, results: [], submittedUrls: 0 };
    }

    // Limit to 10,000 URLs per request (IndexNow limit)
    const urlsToSubmit = urls.slice(0, 10000);

    // Extract host from first URL
    let host: string;
    try {
      const parsedUrl = new URL(urlsToSubmit[0]);
      host = parsedUrl.host;
    } catch {
      this.logger.error(`Invalid URL: ${urlsToSubmit[0]}`);
      return { success: false, results: [], submittedUrls: 0 };
    }

    const payload: IndexNowPayload = {
      host,
      key: this.apiKey,
      keyLocation: `https://${host}/${this.apiKey}.txt`,
      urlList: urlsToSubmit,
    };

    this.logger.log(`ðŸ“¤ IndexNow: Submitting ${urlsToSubmit.length} URLs...`);

    // Submit to all endpoints in parallel
    const results = await Promise.all(
      this.endpoints.map((endpoint) =>
        this.submitToEndpoint(endpoint, payload),
      ),
    );

    const anySuccess = results.some((r) => r.success);

    // Track results
    await this.quotaTracker.trackIndexNow(anySuccess, urlsToSubmit.length);

    return {
      success: anySuccess,
      results,
      submittedUrls: urlsToSubmit.length,
    };
  }

  // ==========================================
  // SUBMIT TO SINGLE ENDPOINT
  // ==========================================

  private async submitToEndpoint(
    endpoint: string,
    payload: IndexNowPayload,
  ): Promise<IndexNowResult> {
    try {
      // âœ… Use axiosRef directly - returns Promise, not Observable
      const response = await this.httpService.axiosRef.post(endpoint, payload, {
        headers: {
          'Content-Type': 'application/json; charset=utf-8',
        },
        validateStatus: () => true, // Don't throw on non-2xx
        timeout: 10000,
      });

      // 200 = OK, 202 = Accepted
      const success = response.status === 200 || response.status === 202;

      this.logger.log(
        `IndexNow ${this.getEndpointName(endpoint)}: ${response.status} ${success ? 'âœ…' : 'âŒ'}`,
      );

      return {
        endpoint,
        status: response.status,
        success,
      };
    } catch (error: unknown) {
      const errorMessage =
        error instanceof Error ? error.message : 'Unknown error';
      this.logger.error(
        `IndexNow ${this.getEndpointName(endpoint)} error: ${errorMessage}`,
      );

      return {
        endpoint,
        status: 500,
        success: false,
        error: errorMessage,
      };
    }
  }

  // ==========================================
  // SUBMIT SINGLE URL
  // ==========================================

  async submitUrl(url: string): Promise<{ success: boolean }> {
    const result = await this.submitUrls([url]);
    return { success: result.success };
  }

  // ==========================================
  // SUBMIT TENANT PAGES
  // ==========================================

  async submitTenantPages(slug: string): Promise<{
    success: boolean;
    urls: string[];
  }> {
    const baseUrl = `https://${slug}.fibidy.com`;

    const urls = [
      baseUrl, // Homepage
      `${baseUrl}/products`, // Products listing
    ];

    const result = await this.submitUrls(urls);
    return { success: result.success, urls };
  }

  // ==========================================
  // SUBMIT PRODUCT PAGE
  // ==========================================

  async submitProductPage(
    tenantSlug: string,
    productSlug?: string,
  ): Promise<{ success: boolean }> {
    const baseUrl = `https://${tenantSlug}.fibidy.com`;

    const urls = [
      productSlug ? `${baseUrl}/p/${productSlug}` : `${baseUrl}/products`,
      `${baseUrl}/products`, // Also refresh products list
    ];

    const result = await this.submitUrls(urls);
    return { success: result.success };
  }

  // ==========================================
  // SERVICE STATUS
  // ==========================================

  isServiceEnabled(): boolean {
    return this.isEnabled;
  }

  getApiKeyPreview(): string {
    if (!this.apiKey) return 'not configured';
    return `${this.apiKey.substring(0, 4)}...${this.apiKey.substring(this.apiKey.length - 4)}`;
  }

  // ==========================================
  // HELPERS
  // ==========================================

  private getEndpointName(endpoint: string): string {
    if (endpoint.includes('bing')) return 'Bing';
    if (endpoint.includes('yandex')) return 'Yandex';
    if (endpoint.includes('indexnow.org')) return 'IndexNow';
    return 'Unknown';
  }
}



================================================================================
FILE: src/seo/services/google-indexing.service.ts
================================================================================

import { Injectable, Logger } from '@nestjs/common';
import { google } from 'googleapis';
import { KeyManagerService } from '../managers/key-manager.service';
import { QuotaTrackerService } from '../managers/quota-tracker.service';
import { GoogleIndexingResult, KeyStats } from '../interfaces';

// ==========================================
// GOOGLE INDEXING SERVICE
// Handles URL submission to Google Indexing API
// With automatic key rotation
// ==========================================

@Injectable()
export class GoogleIndexingService {
  private readonly logger = new Logger(GoogleIndexingService.name);

  constructor(
    private readonly keyManager: KeyManagerService,
    private readonly quotaTracker: QuotaTrackerService,
  ) {}

  // ==========================================
  // SUBMIT SINGLE URL
  // ==========================================

  async submitUrl(
    url: string,
    type: 'URL_UPDATED' | 'URL_DELETED' = 'URL_UPDATED',
  ): Promise<GoogleIndexingResult> {
    // Get next available key
    const key = await this.keyManager.getNextAvailableKey();

    if (!key) {
      this.logger.warn(`No API keys available for: ${url}`);
      return {
        url,
        success: false,
        keyUsed: 'none',
        error: 'No API keys available (quota exhausted)',
      };
    }

    try {
      // Create JWT auth client
      const auth = new google.auth.JWT({
        email: key.clientEmail,
        key: key.privateKey,
        scopes: ['https://www.googleapis.com/auth/indexing'],
      });

      // Create indexing client
      const indexing = google.indexing({ version: 'v3', auth });

      // Submit URL notification
      const response = await indexing.urlNotifications.publish({
        requestBody: {
          url,
          type,
        },
      });

      // Track usage
      await this.keyManager.incrementUsage(key.id);
      await this.quotaTracker.trackGoogleIndexing(true);

      this.logger.log(`âœ… Google Indexed: ${url} (${key.id})`);

      return {
        url,
        success: true,
        keyUsed: key.id,
        response: response.data as GoogleIndexingResult['response'],
      };
    } catch (error: unknown) {
      // Track failure
      await this.keyManager.incrementUsage(key.id);
      await this.quotaTracker.trackGoogleIndexing(false);

      // Handle specific errors
      const errorObj = error as {
        message?: string;
        response?: { status?: number };
        code?: number;
      };
      const errorMessage = errorObj.message || 'Unknown error';
      const statusCode = errorObj.response?.status || errorObj.code;

      this.logger.error(
        `âŒ Google Index failed: ${url} - ${statusCode}: ${errorMessage}`,
      );

      // If auth error, mark key as failed
      if (statusCode === 401 || statusCode === 403) {
        this.keyManager.markKeyAsFailed(key.id);
      }

      return {
        url,
        success: false,
        keyUsed: key.id,
        error: `${statusCode}: ${errorMessage}`,
      };
    }
  }

  // ==========================================
  // SUBMIT BATCH URLs
  // ==========================================

  async submitBatch(
    urls: string[],
    type: 'URL_UPDATED' | 'URL_DELETED' = 'URL_UPDATED',
  ): Promise<GoogleIndexingResult[]> {
    const results: GoogleIndexingResult[] = [];

    // Process URLs with small delay between requests
    for (let i = 0; i < urls.length; i++) {
      const url = urls[i];

      // Check if we have quota
      if (!this.keyManager.hasAvailableQuota()) {
        this.logger.warn(`Quota exhausted at ${i}/${urls.length} URLs`);

        // Mark remaining as failed
        for (let j = i; j < urls.length; j++) {
          results.push({
            url: urls[j],
            success: false,
            keyUsed: 'none',
            error: 'Quota exhausted',
          });
        }
        break;
      }

      const result = await this.submitUrl(url, type);
      results.push(result);

      // Small delay to avoid rate limiting (100ms)
      if (i < urls.length - 1) {
        await this.delay(100);
      }
    }

    return results;
  }

  // ==========================================
  // SUBMIT TENANT PAGES
  // ==========================================

  async submitTenantPages(slug: string): Promise<{
    success: boolean;
    results: GoogleIndexingResult[];
  }> {
    const baseUrl = `https://${slug}.fibidy.com`;

    const urls = [
      baseUrl, // Homepage
      `${baseUrl}/products`, // Products listing
    ];

    const results = await this.submitBatch(urls);
    const success = results.some((r) => r.success);

    return { success, results };
  }

  // ==========================================
  // SUBMIT PRODUCT PAGE
  // ==========================================

  async submitProductPage(
    tenantSlug: string,
    productSlug?: string,
    productId?: string,
  ): Promise<GoogleIndexingResult> {
    const baseUrl = `https://${tenantSlug}.fibidy.com`;

    let productUrl: string;
    if (productSlug) {
      productUrl = `${baseUrl}/p/${productSlug}`;
    } else if (productId) {
      productUrl = `${baseUrl}/product/${productId}`;
    } else {
      productUrl = `${baseUrl}/products`;
    }

    return this.submitUrl(productUrl);
  }

  // ==========================================
  // CHECK SERVICE STATUS
  // ==========================================

  isAvailable(): boolean {
    return this.keyManager.hasAvailableQuota();
  }

  getQuotaStats(): KeyStats {
    return this.keyManager.getStats();
  }

  getRemainingQuota(): number {
    return this.keyManager.getTotalRemainingQuota();
  }

  // ==========================================
  // HELPERS
  // ==========================================

  private delay(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
}



================================================================================
FILE: src/seo/services/google-ping.service.ts
================================================================================

import { Injectable, Logger } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import { QuotaTrackerService } from '../managers/quota-tracker.service';
import { GooglePingResult } from '../interfaces';

// ==========================================
// GOOGLE PING SERVICE
// Notifies Google about sitemap updates
// FREE & UNLIMITED - No API key needed!
// ==========================================

@Injectable()
export class GooglePingService {
  private readonly logger = new Logger(GooglePingService.name);
  private readonly pingUrl = 'https://www.google.com/ping';

  constructor(
    private readonly httpService: HttpService,
    private readonly quotaTracker: QuotaTrackerService,
  ) {
    this.logger.log('âœ… Google Ping service ready (FREE & unlimited)');
  }

  // ==========================================
  // PING SITEMAP URL
  // ==========================================

  async pingSitemap(sitemapUrl: string): Promise<GooglePingResult> {
    try {
      const url = `${this.pingUrl}?sitemap=${encodeURIComponent(sitemapUrl)}`;

      this.logger.debug(`Pinging Google: ${sitemapUrl}`);

      // âœ… Use axiosRef directly - returns Promise, not Observable
      const response = await this.httpService.axiosRef.get(url, {
        validateStatus: () => true,
        timeout: 10000,
      });

      const success = response.status === 200;

      // Track result
      await this.quotaTracker.trackGooglePing(success);

      this.logger.log(
        `Google Ping: ${response.status} ${success ? 'âœ…' : 'âŒ'} - ${sitemapUrl}`,
      );

      return {
        sitemapUrl,
        success,
        status: response.status,
      };
    } catch (error: unknown) {
      const errorMessage =
        error instanceof Error ? error.message : 'Unknown error';
      this.logger.error(`Google Ping failed: ${sitemapUrl} - ${errorMessage}`);

      await this.quotaTracker.trackGooglePing(false);

      return {
        sitemapUrl,
        success: false,
        status: 500,
        error: errorMessage,
      };
    }
  }

  // ==========================================
  // PING TENANT SITEMAP
  // ==========================================

  async pingTenantSitemap(slug: string): Promise<GooglePingResult> {
    const sitemapUrl = `https://${slug}.fibidy.com/sitemap.xml`;
    return this.pingSitemap(sitemapUrl);
  }

  // ==========================================
  // PING PLATFORM SITEMAP INDEX
  // ==========================================

  async pingPlatformSitemap(): Promise<GooglePingResult> {
    const sitemapUrl = 'https://fibidy.com/server-sitemap-index.xml';
    return this.pingSitemap(sitemapUrl);
  }

  // ==========================================
  // PING MULTIPLE SITEMAPS
  // ==========================================

  async pingMultipleSitemaps(
    sitemapUrls: string[],
  ): Promise<GooglePingResult[]> {
    const results: GooglePingResult[] = [];

    for (const sitemapUrl of sitemapUrls) {
      const result = await this.pingSitemap(sitemapUrl);
      results.push(result);

      // Small delay between pings
      await this.delay(200);
    }

    return results;
  }

  // ==========================================
  // PING ALL (Platform + Tenant)
  // ==========================================

  async pingAll(tenantSlug: string): Promise<{
    platform: GooglePingResult;
    tenant: GooglePingResult;
  }> {
    const [platform, tenant] = await Promise.all([
      this.pingPlatformSitemap(),
      this.pingTenantSitemap(tenantSlug),
    ]);

    return { platform, tenant };
  }

  // ==========================================
  // HELPERS
  // ==========================================

  private delay(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
}



================================================================================
FILE: src/sitemap/sitemap.module.ts
================================================================================

import { Module } from '@nestjs/common';
import { SitemapController } from './sitemap.controller';
import { SitemapService } from './sitemap.service';

// ==========================================
// SITEMAP MODULE
// Public endpoints for sitemap data
// ==========================================

@Module({
  controllers: [SitemapController],
  providers: [SitemapService],
  exports: [SitemapService],
})
export class SitemapModule {}



================================================================================
FILE: src/sitemap/sitemap.controller.ts
================================================================================

import {
  Controller,
  Get,
  Query,
  ParseIntPipe,
  DefaultValuePipe,
} from '@nestjs/common';
import { SitemapService } from './sitemap.service';

// ==========================================
// SITEMAP CONTROLLER
// Public endpoints - NO AUTH REQUIRED
// ==========================================

@Controller('sitemap')
export class SitemapController {
  constructor(private readonly sitemapService: SitemapService) {}

  // ==========================================
  // PAGINATED ENDPOINTS (For scalable sitemap)
  // ==========================================

  /**
   * Get paginated tenants for sitemap
   * GET /api/sitemap/tenants/paginated?page=1&limit=1000
   */
  @Get('tenants/paginated')
  async getTenantsPaginated(
    @Query('page', new DefaultValuePipe(1), ParseIntPipe) page: number,
    @Query('limit', new DefaultValuePipe(1000), ParseIntPipe) limit: number,
  ) {
    return this.sitemapService.getTenantsForSitemapPaginated(
      page,
      Math.min(limit, 5000), // Max 5000 per request
    );
  }

  /**
   * Get paginated products for sitemap
   * GET /api/sitemap/products/paginated?page=1&limit=1000
   */
  @Get('products/paginated')
  async getProductsPaginated(
    @Query('page', new DefaultValuePipe(1), ParseIntPipe) page: number,
    @Query('limit', new DefaultValuePipe(1000), ParseIntPipe) limit: number,
  ) {
    return this.sitemapService.getProductsForSitemapPaginated(
      page,
      Math.min(limit, 5000), // Max 5000 per request
    );
  }

  // ==========================================
  // SIMPLE ENDPOINTS (For small scale / backward compat)
  // ==========================================

  /**
   * Get all active tenants for sitemap
   * GET /api/sitemap/tenants
   */
  @Get('tenants')
  async getTenants() {
    return this.sitemapService.getTenantsForSitemap();
  }

  /**
   * Get all active products for sitemap
   * GET /api/sitemap/products
   */
  @Get('products')
  async getProducts() {
    return this.sitemapService.getProductsForSitemap();
  }

  /**
   * Get sitemap statistics
   * GET /api/sitemap/stats
   */
  @Get('stats')
  async getStats() {
    return this.sitemapService.getSitemapStats();
  }
}



================================================================================
FILE: src/sitemap/sitemap.service.ts
================================================================================

import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';

// ==========================================
// SITEMAP SERVICE
// Provides data for sitemap generation
// ==========================================

@Injectable()
export class SitemapService {
  constructor(private prisma: PrismaService) {}

  // ==========================================
  // PAGINATED: TENANTS
  // ==========================================

  async getTenantsForSitemapPaginated(page: number = 1, limit: number = 1000) {
    const skip = (page - 1) * limit;

    const [tenants, total] = await Promise.all([
      this.prisma.tenant.findMany({
        where: { status: 'ACTIVE' },
        select: {
          slug: true,
          updatedAt: true,
        },
        orderBy: { createdAt: 'asc' },
        skip,
        take: limit,
      }),
      this.prisma.tenant.count({
        where: { status: 'ACTIVE' },
      }),
    ]);

    return {
      tenants: tenants.map((t) => ({
        slug: t.slug,
        updatedAt: t.updatedAt.toISOString(),
      })),
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit),
    };
  }

  // ==========================================
  // PAGINATED: PRODUCTS
  // ==========================================

  async getProductsForSitemapPaginated(page: number = 1, limit: number = 1000) {
    const skip = (page - 1) * limit;

    const [products, total] = await Promise.all([
      this.prisma.product.findMany({
        where: {
          isActive: true,
          tenant: { status: 'ACTIVE' },
        },
        select: {
          id: true,
          slug: true,
          updatedAt: true,
          tenant: {
            select: { slug: true },
          },
        },
        orderBy: { createdAt: 'asc' },
        skip,
        take: limit,
      }),
      this.prisma.product.count({
        where: {
          isActive: true,
          tenant: { status: 'ACTIVE' },
        },
      }),
    ]);

    return {
      products: products.map((p) => ({
        id: p.id,
        slug: p.slug,
        tenantSlug: p.tenant.slug,
        updatedAt: p.updatedAt.toISOString(),
      })),
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit),
    };
  }

  // ==========================================
  // SIMPLE: ALL TENANTS (for small scale)
  // ==========================================

  async getTenantsForSitemap() {
    const tenants = await this.prisma.tenant.findMany({
      where: { status: 'ACTIVE' },
      select: {
        slug: true,
        updatedAt: true,
      },
      orderBy: { updatedAt: 'desc' },
    });

    return {
      tenants: tenants.map((t) => ({
        slug: t.slug,
        updatedAt: t.updatedAt.toISOString(),
      })),
      total: tenants.length,
    };
  }

  // ==========================================
  // SIMPLE: ALL PRODUCTS (for small scale)
  // ==========================================

  async getProductsForSitemap() {
    const products = await this.prisma.product.findMany({
      where: {
        isActive: true,
        tenant: { status: 'ACTIVE' },
      },
      select: {
        id: true,
        slug: true,
        updatedAt: true,
        tenant: {
          select: { slug: true },
        },
      },
      orderBy: { updatedAt: 'desc' },
    });

    return {
      products: products.map((p) => ({
        id: p.id,
        slug: p.slug,
        tenantSlug: p.tenant.slug,
        updatedAt: p.updatedAt.toISOString(),
      })),
      total: products.length,
    };
  }

  // ==========================================
  // STATS
  // ==========================================

  async getSitemapStats() {
    const [tenantCount, productCount, lastTenantUpdate, lastProductUpdate] =
      await Promise.all([
        this.prisma.tenant.count({
          where: { status: 'ACTIVE' },
        }),
        this.prisma.product.count({
          where: {
            isActive: true,
            tenant: { status: 'ACTIVE' },
          },
        }),
        this.prisma.tenant.findFirst({
          where: { status: 'ACTIVE' },
          orderBy: { updatedAt: 'desc' },
          select: { updatedAt: true },
        }),
        this.prisma.product.findFirst({
          where: {
            isActive: true,
            tenant: { status: 'ACTIVE' },
          },
          orderBy: { updatedAt: 'desc' },
          select: { updatedAt: true },
        }),
      ]);

    // Calculate estimated URLs
    // Static pages (8) + tenant URLs (2 per tenant) + product URLs
    const staticPages = 8;
    const tenantPages = tenantCount * 2; // store homepage + products page per tenant
    const totalUrls = staticPages + tenantPages + productCount;

    return {
      stats: {
        tenants: tenantCount,
        products: productCount,
        estimatedUrls: totalUrls,
        lastTenantUpdate: lastTenantUpdate?.updatedAt?.toISOString() || null,
        lastProductUpdate: lastProductUpdate?.updatedAt?.toISOString() || null,
      },
      generatedAt: new Date().toISOString(),
    };
  }
}



================================================================================
FILE: src/tenants/tenants.module.ts
================================================================================

import { Module } from '@nestjs/common';
import { TenantsService } from './tenants.service';
import { TenantsController } from './tenants.controller';

@Module({
  controllers: [TenantsController],
  providers: [TenantsService],
  exports: [TenantsService],
})
export class TenantsModule {}



================================================================================
FILE: src/tenants/tenants.controller.ts
================================================================================

import {
  Controller,
  Get,
  Patch,
  Body,
  Param,
  Query,
  UseGuards,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { TenantsService } from './tenants.service';
import { UpdateTenantDto, ChangePasswordDto } from './dto';
import { JwtAuthGuard } from '../common/guards/jwt-auth.guard';
import { CurrentTenant } from '../common/decorators/tenant.decorator';

@Controller('tenants')
export class TenantsController {
  constructor(private tenantsService: TenantsService) {}

  // ==========================================
  // PUBLIC ENDPOINTS
  // ==========================================

  /**
   * Get tenant by slug (for store frontend)
   * GET /api/tenants/by-slug/:slug
   * Public - No auth required
   */
  @Get('by-slug/:slug')
  async findBySlug(@Param('slug') slug: string) {
    return this.tenantsService.findBySlug(slug);
  }

  /**
   * Get products by tenant slug (for store frontend)
   * GET /api/tenants/by-slug/:slug/products
   * Public - No auth required
   */
  @Get('by-slug/:slug/products')
  async findProductsBySlug(
    @Param('slug') slug: string,
    @Query('category') category?: string,
  ) {
    return this.tenantsService.findProductsBySlug(slug, category);
  }

  /**
   * Check slug availability (for registration form)
   * GET /api/tenants/check-slug/:slug
   * Public - No auth required
   */
  @Get('check-slug/:slug')
  async checkSlug(@Param('slug') slug: string) {
    return this.tenantsService.checkSlugAvailability(slug);
  }

  // ==========================================
  // PROTECTED ENDPOINTS
  // ==========================================

  /**
   * Get current tenant profile
   * GET /api/tenants/me
   * Requires: Bearer token
   */
  @Get('me')
  @UseGuards(JwtAuthGuard)
  async findMe(@CurrentTenant('id') tenantId: string) {
    return this.tenantsService.findMe(tenantId);
  }

  /**
   * Update current tenant profile
   * PATCH /api/tenants/me
   * Requires: Bearer token
   */
  @Patch('me')
  @UseGuards(JwtAuthGuard)
  @HttpCode(HttpStatus.OK)
  async updateMe(
    @CurrentTenant('id') tenantId: string,
    @Body() dto: UpdateTenantDto,
  ) {
    return this.tenantsService.updateMe(tenantId, dto);
  }

  /**
   * Change password
   * PATCH /api/tenants/me/password
   * Requires: Bearer token
   */
  @Patch('me/password')
  @UseGuards(JwtAuthGuard)
  @HttpCode(HttpStatus.OK)
  async changePassword(
    @CurrentTenant('id') tenantId: string,
    @Body() dto: ChangePasswordDto,
  ) {
    return this.tenantsService.changePassword(tenantId, dto);
  }

  /**
   * Get dashboard stats
   * GET /api/tenants/me/stats
   * Requires: Bearer token
   */
  @Get('me/stats')
  @UseGuards(JwtAuthGuard)
  async getStats(@CurrentTenant('id') tenantId: string) {
    return this.tenantsService.getDashboardStats(tenantId);
  }
}



================================================================================
FILE: src/tenants/tenants.service.ts
================================================================================

import {
  Injectable,
  NotFoundException,
  BadRequestException,
} from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { RedisService, CACHE_TTL, CACHE_KEYS } from '../redis/redis.service';
import { SeoService } from '../seo/seo.service';
import { Prisma } from '@prisma/client';
import { UpdateTenantDto, ChangePasswordDto } from './dto';
import * as bcrypt from 'bcrypt';

// ðŸ”¥ NEW: Import validator
import { validateAndSanitizeLandingConfig } from '../validators/landing-config.validator';

@Injectable()
export class TenantsService {
  constructor(
    private prisma: PrismaService,
    private redis: RedisService,
    private seoService: SeoService, // ðŸš€ ADD THIS
  ) {}

  // ==========================================
  // PUBLIC: GET TENANT BY SLUG (dengan caching)
  // ==========================================
  async findBySlug(slug: string) {
    const cacheKey = CACHE_KEYS.TENANT_SLUG(slug.toLowerCase());

    return this.redis.getOrSet(
      cacheKey,
      async () => {
        const tenant = await this.prisma.tenant.findUnique({
          where: { slug: slug.toLowerCase() },
          select: {
            id: true,
            slug: true,
            name: true,
            category: true,
            description: true,
            whatsapp: true,
            phone: true,
            address: true,
            logo: true,
            banner: true,
            theme: true,
            landingConfig: true,
            metaTitle: true,
            metaDescription: true,
            socialLinks: true,
            currency: true,
            taxRate: true,
            paymentMethods: true,
            freeShippingThreshold: true,
            defaultShippingCost: true,
            shippingMethods: true,
            status: true,
            createdAt: true,
            _count: {
              select: {
                products: {
                  where: { isActive: true },
                },
              },
            },
          },
        });

        if (!tenant) {
          throw new NotFoundException(
            `Toko dengan slug "${slug}" tidak ditemukan`,
          );
        }

        if (tenant.status !== 'ACTIVE') {
          throw new NotFoundException(`Toko tidak aktif`);
        }

        return tenant;
      },
      CACHE_TTL.TENANT_PUBLIC,
    );
  }

  // ==========================================
  // PUBLIC: GET PRODUCTS BY SLUG (dengan caching)
  // ==========================================
  async findProductsBySlug(slug: string, category?: string) {
    const cacheKey = category
      ? `${CACHE_KEYS.TENANT_PRODUCTS_PUBLIC(slug)}:${category}`
      : CACHE_KEYS.TENANT_PRODUCTS_PUBLIC(slug);

    return this.redis.getOrSet(
      cacheKey,
      async () => {
        const tenant = await this.prisma.tenant.findUnique({
          where: { slug: slug.toLowerCase() },
          select: { id: true, status: true },
        });

        if (!tenant) {
          throw new NotFoundException(
            `Toko dengan slug "${slug}" tidak ditemukan`,
          );
        }

        if (tenant.status !== 'ACTIVE') {
          throw new NotFoundException(`Toko tidak aktif`);
        }

        const products = await this.prisma.product.findMany({
          where: {
            tenantId: tenant.id,
            isActive: true,
            ...(category && { category }),
          },
          select: {
            id: true,
            name: true,
            description: true,
            category: true,
            price: true,
            comparePrice: true,
            stock: true,
            trackStock: true,
            unit: true,
            images: true,
            isFeatured: true,
            slug: true,
          },
          orderBy: [{ isFeatured: 'desc' }, { createdAt: 'desc' }],
        });

        return products;
      },
      CACHE_TTL.PRODUCT_LIST,
    );
  }

  // ==========================================
  // PROTECTED: GET ME
  // ==========================================
  async findMe(tenantId: string) {
    const cacheKey = CACHE_KEYS.TENANT_ID(tenantId);

    return this.redis.getOrSet(
      cacheKey,
      async () => {
        const tenant = await this.prisma.tenant.findUnique({
          where: { id: tenantId },
          select: {
            id: true,
            slug: true,
            name: true,
            email: true,
            category: true,
            description: true,
            whatsapp: true,
            phone: true,
            address: true,
            logo: true,
            banner: true,
            theme: true,
            landingConfig: true,
            metaTitle: true,
            metaDescription: true,
            socialLinks: true,
            currency: true,
            taxRate: true,
            paymentMethods: true,
            freeShippingThreshold: true,
            defaultShippingCost: true,
            shippingMethods: true,
            status: true,
            createdAt: true,
            updatedAt: true,
            _count: {
              select: {
                products: true,
                customers: true,
                orders: true,
              },
            },
          },
        });

        if (!tenant) {
          throw new NotFoundException('Tenant tidak ditemukan');
        }

        return tenant;
      },
      CACHE_TTL.TENANT_PRIVATE,
    );
  }

  // ==========================================
  // ðŸ”¥ UPDATED: UPDATE ME with LandingConfig Validation
  // ==========================================
  async updateMe(tenantId: string, dto: UpdateTenantDto) {
    const existing = await this.prisma.tenant.findUnique({
      where: { id: tenantId },
      select: { slug: true },
    });

    if (!existing) {
      throw new NotFoundException('Tenant tidak ditemukan');
    }

    // ==========================================
    // ðŸ”¥ NEW: Validate landingConfig before save
    // ==========================================
    let validatedLandingConfig: Prisma.InputJsonValue | undefined = undefined;

    if (dto.landingConfig !== undefined) {
      const validationResult = validateAndSanitizeLandingConfig(
        dto.landingConfig,
      );

      if (!validationResult.valid) {
        throw new BadRequestException({
          message: 'Invalid landing page configuration',
          errors: validationResult.errors,
          code: 'INVALID_LANDING_CONFIG',
        });
      }

      validatedLandingConfig =
        validationResult.data as unknown as Prisma.InputJsonValue;

      // Log warnings for debugging
      if (validationResult.warnings?.length) {
        console.warn(
          `[TenantsService] Landing config warnings for tenant ${tenantId}:`,
          validationResult.warnings,
        );
      }
    }

    const tenant = await this.prisma.tenant.update({
      where: { id: tenantId },
      data: {
        // Basic info
        name: dto.name,
        description: dto.description,
        whatsapp: dto.whatsapp,
        phone: dto.phone,
        address: dto.address,
        logo: dto.logo,
        banner: dto.banner,
        theme: dto.theme,
        // ðŸ”¥ UPDATED: Use validated config
        landingConfig: validatedLandingConfig,
        // SEO
        metaTitle: dto.metaTitle,
        metaDescription: dto.metaDescription,
        socialLinks: dto.socialLinks as unknown as Prisma.InputJsonValue,
        // Payment & Shipping
        currency: dto.currency,
        taxRate: dto.taxRate,
        paymentMethods: dto.paymentMethods as unknown as Prisma.InputJsonValue,
        freeShippingThreshold: dto.freeShippingThreshold,
        defaultShippingCost: dto.defaultShippingCost,
        shippingMethods:
          dto.shippingMethods as unknown as Prisma.InputJsonValue,
      },
      select: {
        id: true,
        slug: true,
        name: true,
        email: true,
        category: true,
        description: true,
        whatsapp: true,
        phone: true,
        address: true,
        logo: true,
        banner: true,
        theme: true,
        landingConfig: true,
        metaTitle: true,
        metaDescription: true,
        socialLinks: true,
        currency: true,
        taxRate: true,
        paymentMethods: true,
        freeShippingThreshold: true,
        defaultShippingCost: true,
        shippingMethods: true,
        status: true,
        updatedAt: true,
      },
    });

    // ðŸ”¥ INVALIDATE CACHE
    await this.redis.invalidateTenant(tenantId, existing.slug);
    this.seoService.onTenantUpdated(existing.slug).catch((error) => {
      console.error('[SEO] Failed to reindex tenant:', error.message);
    });
    return {
      message: 'Profil berhasil diupdate',
      tenant,
    };
  }

  // ==========================================
  // PROTECTED: CHANGE PASSWORD
  // ==========================================
  async changePassword(tenantId: string, dto: ChangePasswordDto) {
    if (dto.newPassword !== dto.confirmPassword) {
      throw new BadRequestException('Konfirmasi password tidak cocok');
    }

    const tenant = await this.prisma.tenant.findUnique({
      where: { id: tenantId },
      select: { id: true, password: true },
    });

    if (!tenant) {
      throw new NotFoundException('Tenant tidak ditemukan');
    }

    const isPasswordValid = await bcrypt.compare(
      dto.currentPassword,
      tenant.password,
    );

    if (!isPasswordValid) {
      throw new BadRequestException('Password lama tidak sesuai');
    }

    const isSamePassword = await bcrypt.compare(
      dto.newPassword,
      tenant.password,
    );

    if (isSamePassword) {
      throw new BadRequestException(
        'Password baru tidak boleh sama dengan password lama',
      );
    }

    const hashedPassword = await bcrypt.hash(dto.newPassword, 12); // ðŸ”¥ Increased from 10 to 12

    await this.prisma.tenant.update({
      where: { id: tenantId },
      data: { password: hashedPassword },
    });

    return {
      message: 'Password berhasil diubah',
    };
  }

  // ==========================================
  // ðŸš€ OPTIMIZED: GET DASHBOARD STATS
  // ==========================================
  async getDashboardStats(tenantId: string) {
    const cacheKey = CACHE_KEYS.TENANT_STATS(tenantId);

    return this.redis.getOrSet(
      cacheKey,
      async () => {
        const now = new Date();
        const startOfToday = new Date(
          now.getFullYear(),
          now.getMonth(),
          now.getDate(),
        );
        const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
        const startOfLastMonth = new Date(
          now.getFullYear(),
          now.getMonth() - 1,
          1,
        );
        const endOfLastMonth = new Date(now.getFullYear(), now.getMonth(), 0);
        const startOfWeek = new Date(now);
        startOfWeek.setDate(now.getDate() - 7);

        const [productStats, customerStats, orderStats, revenueStats] =
          await Promise.all([
            this.prisma.$queryRaw<
              [{ total: bigint; active: bigint; low_stock: bigint }]
            >`
            SELECT 
              COUNT(*) as total,
              COUNT(*) FILTER (WHERE "isActive" = true) as active,
              COUNT(*) FILTER (WHERE "isActive" = true AND "trackStock" = true AND stock <= 5) as low_stock
            FROM "Product"
            WHERE "tenantId" = ${tenantId}
          `,
            this.prisma.$queryRaw<
              [{ total: bigint; this_month: bigint; last_month: bigint }]
            >`
            SELECT 
              COUNT(*) as total,
              COUNT(*) FILTER (WHERE "createdAt" >= ${startOfMonth}) as this_month,
              COUNT(*) FILTER (WHERE "createdAt" >= ${startOfLastMonth} AND "createdAt" <= ${endOfLastMonth}) as last_month
            FROM "Customer"
            WHERE "tenantId" = ${tenantId}
          `,
            this.prisma.$queryRaw<
              [
                {
                  total: bigint;
                  today: bigint;
                  this_week: bigint;
                  this_month: bigint;
                  last_month: bigint;
                  pending: bigint;
                },
              ]
            >`
            SELECT 
              COUNT(*) as total,
              COUNT(*) FILTER (WHERE "createdAt" >= ${startOfToday}) as today,
              COUNT(*) FILTER (WHERE "createdAt" >= ${startOfWeek}) as this_week,
              COUNT(*) FILTER (WHERE "createdAt" >= ${startOfMonth}) as this_month,
              COUNT(*) FILTER (WHERE "createdAt" >= ${startOfLastMonth} AND "createdAt" <= ${endOfLastMonth}) as last_month,
              COUNT(*) FILTER (WHERE status = 'PENDING') as pending
            FROM "Order"
            WHERE "tenantId" = ${tenantId}
          `,
            this.prisma.$queryRaw<
              [
                {
                  this_week: number | null;
                  this_month: number | null;
                  last_month: number | null;
                },
              ]
            >`
            SELECT 
              COALESCE(SUM(total) FILTER (WHERE "createdAt" >= ${startOfWeek} AND status IN ('PROCESSING', 'COMPLETED')), 0) as this_week,
              COALESCE(SUM(total) FILTER (WHERE "createdAt" >= ${startOfMonth} AND status IN ('PROCESSING', 'COMPLETED')), 0) as this_month,
              COALESCE(SUM(total) FILTER (WHERE "createdAt" >= ${startOfLastMonth} AND "createdAt" <= ${endOfLastMonth} AND status IN ('PROCESSING', 'COMPLETED')), 0) as last_month
            FROM "Order"
            WHERE "tenantId" = ${tenantId}
          `,
          ]);

        const [recentOrders, lowStockItems] = await Promise.all([
          this.prisma.order.findMany({
            where: { tenantId },
            orderBy: { createdAt: 'desc' },
            take: 5,
            select: {
              id: true,
              orderNumber: true,
              total: true,
              status: true,
              paymentStatus: true,
              createdAt: true,
              customer: {
                select: { id: true, name: true, phone: true },
              },
              customerName: true,
              customerPhone: true,
            },
          }),
          this.prisma.product.findMany({
            where: {
              tenantId,
              isActive: true,
              trackStock: true,
              stock: { lte: 5 },
            },
            orderBy: { stock: 'asc' },
            take: 5,
            select: {
              id: true,
              name: true,
              stock: true,
              sku: true,
            },
          }),
        ]);

        const calculateTrend = (current: number, previous: number): number => {
          if (previous === 0) return current > 0 ? 100 : 0;
          return Math.round(((current - previous) / previous) * 100);
        };

        const products = {
          total: Number(productStats[0]?.total ?? 0),
          active: Number(productStats[0]?.active ?? 0),
          lowStock: Number(productStats[0]?.low_stock ?? 0),
        };

        const customersThisMonth = Number(customerStats[0]?.this_month ?? 0);
        const customersLastMonth = Number(customerStats[0]?.last_month ?? 0);
        const ordersThisMonth = Number(orderStats[0]?.this_month ?? 0);
        const ordersLastMonth = Number(orderStats[0]?.last_month ?? 0);
        const thisMonthRevenue = Number(revenueStats[0]?.this_month ?? 0);
        const lastMonthRevenue = Number(revenueStats[0]?.last_month ?? 0);

        return {
          products,
          customers: {
            total: Number(customerStats[0]?.total ?? 0),
            thisMonth: customersThisMonth,
            trend: calculateTrend(customersThisMonth, customersLastMonth),
          },
          orders: {
            total: Number(orderStats[0]?.total ?? 0),
            today: Number(orderStats[0]?.today ?? 0),
            thisWeek: Number(orderStats[0]?.this_week ?? 0),
            thisMonth: ordersThisMonth,
            pending: Number(orderStats[0]?.pending ?? 0),
            trend: calculateTrend(ordersThisMonth, ordersLastMonth),
          },
          revenue: {
            thisWeek: Number(revenueStats[0]?.this_week ?? 0),
            thisMonth: thisMonthRevenue,
            lastMonth: lastMonthRevenue,
            trend: calculateTrend(thisMonthRevenue, lastMonthRevenue),
          },
          alerts: {
            lowStock: products.lowStock,
            pendingOrders: Number(orderStats[0]?.pending ?? 0),
          },
          recentOrders,
          lowStockItems,
        };
      },
      CACHE_TTL.DASHBOARD_STATS,
    );
  }

  // ==========================================
  // HELPER: Check slug availability
  // ==========================================
  async checkSlugAvailability(slug: string) {
    const existing = await this.prisma.tenant.findUnique({
      where: { slug: slug.toLowerCase() },
      select: { id: true },
    });

    return {
      slug: slug.toLowerCase(),
      available: !existing,
    };
  }
}



================================================================================
FILE: src/tenants/dto/index.ts
================================================================================

export * from './update-tenant.dto';
export * from './change-password.dto';



================================================================================
FILE: src/tenants/dto/update-tenant.dto.ts
================================================================================

import {
  IsString,
  IsOptional,
  MinLength,
  MaxLength,
  Matches,
  IsObject,
  IsBoolean,
  IsUrl,
  ValidateNested,
  IsNumber,
  Min,
  Max,
  IsArray,
  IsIn,
} from 'class-validator';
import { Type, Transform } from 'class-transformer';

// ==========================================
// SOCIAL LINKS DTO
// ==========================================

class SocialLinksDto {
  @IsOptional()
  @IsString()
  @IsUrl({}, { message: 'Instagram harus berupa URL yang valid' })
  instagram?: string;

  @IsOptional()
  @IsString()
  @IsUrl({}, { message: 'Facebook harus berupa URL yang valid' })
  facebook?: string;

  @IsOptional()
  @IsString()
  @IsUrl({}, { message: 'TikTok harus berupa URL yang valid' })
  tiktok?: string;

  @IsOptional()
  @IsString()
  @IsUrl({}, { message: 'YouTube harus berupa URL yang valid' })
  youtube?: string;

  @IsOptional()
  @IsString()
  @IsUrl({}, { message: 'Twitter/X harus berupa URL yang valid' })
  twitter?: string;
}

// ==========================================
// PAYMENT SETTINGS DTOs
// ==========================================

class BankAccountDto {
  @IsString()
  id: string;

  @IsString()
  @IsIn(
    [
      'BCA',
      'Mandiri',
      'BNI',
      'BRI',
      'BSI',
      'CIMB',
      'Permata',
      'Danamon',
      'Other',
    ],
    {
      message: 'Bank tidak valid',
    },
  )
  bank: string;

  @IsString()
  @MinLength(5, { message: 'Nomor rekening minimal 5 digit' })
  @MaxLength(20, { message: 'Nomor rekening maksimal 20 digit' })
  accountNumber: string;

  @IsString()
  @MinLength(3, { message: 'Nama pemilik rekening minimal 3 karakter' })
  @MaxLength(100, { message: 'Nama pemilik rekening maksimal 100 karakter' })
  accountName: string;

  @IsBoolean()
  enabled: boolean;
}

class EWalletDto {
  @IsString()
  id: string;

  @IsString()
  @IsIn(['GoPay', 'OVO', 'DANA', 'ShopeePay', 'LinkAja', 'Other'], {
    message: 'Provider e-wallet tidak valid',
  })
  provider: string;

  @IsString()
  @Matches(/^(\+62|62|0)[0-9]{9,13}$/, {
    message: 'Format nomor e-wallet tidak valid',
  })
  number: string;

  @IsOptional()
  @IsString()
  @MaxLength(100)
  name?: string;

  @IsBoolean()
  enabled: boolean;
}

class CodSettingsDto {
  @IsBoolean()
  enabled: boolean;

  @IsOptional()
  @IsString()
  @MaxLength(200, { message: 'Catatan COD maksimal 200 karakter' })
  note?: string;
}

class PaymentMethodsDto {
  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => BankAccountDto)
  bankAccounts?: BankAccountDto[];

  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => EWalletDto)
  eWallets?: EWalletDto[];

  @IsOptional()
  @ValidateNested()
  @Type(() => CodSettingsDto)
  cod?: CodSettingsDto;
}

// ==========================================
// SHIPPING SETTINGS DTOs
// ==========================================

class CourierDto {
  @IsString()
  id: string;

  @IsString()
  @IsIn(
    [
      'JNE',
      'J&T Express',
      'SiCepat',
      'AnterAja',
      'Ninja Express',
      'ID Express',
      'SAP Express',
      'Lion Parcel',
      'Pos Indonesia',
      'TIKI',
      'Other',
    ],
    {
      message: 'Kurir tidak valid',
    },
  )
  name: string;

  @IsBoolean()
  enabled: boolean;

  @IsOptional()
  @IsString()
  @MaxLength(100, { message: 'Catatan kurir maksimal 100 karakter' })
  note?: string;
}

class ShippingMethodsDto {
  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => CourierDto)
  couriers?: CourierDto[];
}

// ==========================================
// TESTIMONIAL ITEM DTO (NEW - FIXED!)
// ==========================================

class TestimonialItemDto {
  @IsString()
  id: string;

  @IsString()
  name: string;

  @IsOptional()
  @IsString()
  role?: string;

  @IsOptional()
  @IsString()
  avatar?: string;

  @IsString()
  content: string;

  @IsOptional()
  @IsNumber()
  rating?: number;
}

// ==========================================
// FEATURE ITEM DTO
// ==========================================

class FeatureItemDto {
  @IsOptional()
  @IsString()
  icon?: string;

  @IsString()
  title: string;

  @IsString()
  description: string;
}

// ==========================================
// LANDING SECTION CONFIG DTOs (SEPARATED!)
// ==========================================

class HeroSectionConfigDto {
  @IsOptional()
  @IsString()
  layout?: string;

  @IsOptional()
  @IsBoolean()
  showCta?: boolean;

  @IsOptional()
  @IsString()
  ctaText?: string;

  @IsOptional()
  @IsString()
  ctaLink?: string;

  @IsOptional()
  @IsString()
  backgroundImage?: string;

  @IsOptional()
  @IsNumber()
  overlayOpacity?: number;
}

class AboutSectionConfigDto {
  @IsOptional()
  @IsString()
  content?: string;

  @IsOptional()
  @IsBoolean()
  showImage?: boolean;

  @IsOptional()
  @IsString()
  image?: string;

  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => FeatureItemDto)
  features?: FeatureItemDto[];
}

class ProductsSectionConfigDto {
  @IsOptional()
  @IsString()
  displayMode?: string;

  @IsOptional()
  @IsNumber()
  limit?: number;

  @IsOptional()
  @IsBoolean()
  showViewAll?: boolean;
}

// âœ… FIXED: Separate DTO for testimonials config with proper Transform
class TestimonialsSectionConfigDto {
  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => TestimonialItemDto)
  @Transform(({ value }) => {
    // âœ… FIX: Flatten nested arrays during transformation
    if (!value) return [];

    let items = value;

    // Handle nested array bug: [[item]] -> [item]
    while (
      Array.isArray(items) &&
      items.length > 0 &&
      Array.isArray(items[0])
    ) {
      items = items[0];
    }

    if (!Array.isArray(items)) return [];

    // Filter valid items
    return items.filter(
      (item: any) =>
        item &&
        typeof item === 'object' &&
        typeof item.id === 'string' &&
        typeof item.name === 'string' &&
        typeof item.content === 'string',
    );
  })
  items?: TestimonialItemDto[];
}

class ContactSectionConfigDto {
  @IsOptional()
  @IsBoolean()
  showMap?: boolean;

  @IsOptional()
  @IsBoolean()
  showForm?: boolean;

  @IsOptional()
  @IsBoolean()
  showSocialMedia?: boolean;
}

class CtaSectionConfigDto {
  @IsOptional()
  @IsString()
  buttonText?: string;

  @IsOptional()
  @IsString()
  buttonLink?: string;

  @IsOptional()
  @IsString()
  style?: string;
}

// ==========================================
// LANDING SECTION DTOs (SEPARATED BY TYPE!)
// ==========================================

class HeroSectionDto {
  @IsOptional()
  @IsBoolean()
  enabled?: boolean;

  @IsOptional()
  @IsString()
  title?: string;

  @IsOptional()
  @IsString()
  subtitle?: string;

  @IsOptional()
  @ValidateNested()
  @Type(() => HeroSectionConfigDto)
  config?: HeroSectionConfigDto;
}

class AboutSectionDto {
  @IsOptional()
  @IsBoolean()
  enabled?: boolean;

  @IsOptional()
  @IsString()
  title?: string;

  @IsOptional()
  @IsString()
  subtitle?: string;

  @IsOptional()
  @ValidateNested()
  @Type(() => AboutSectionConfigDto)
  config?: AboutSectionConfigDto;
}

class ProductsSectionDto {
  @IsOptional()
  @IsBoolean()
  enabled?: boolean;

  @IsOptional()
  @IsString()
  title?: string;

  @IsOptional()
  @IsString()
  subtitle?: string;

  @IsOptional()
  @ValidateNested()
  @Type(() => ProductsSectionConfigDto)
  config?: ProductsSectionConfigDto;
}

// âœ… FIXED: Testimonials section with proper config type
class TestimonialsSectionDto {
  @IsOptional()
  @IsBoolean()
  enabled?: boolean;

  @IsOptional()
  @IsString()
  title?: string;

  @IsOptional()
  @IsString()
  subtitle?: string;

  @IsOptional()
  @ValidateNested()
  @Type(() => TestimonialsSectionConfigDto)
  config?: TestimonialsSectionConfigDto;
}

class ContactSectionDto {
  @IsOptional()
  @IsBoolean()
  enabled?: boolean;

  @IsOptional()
  @IsString()
  title?: string;

  @IsOptional()
  @IsString()
  subtitle?: string;

  @IsOptional()
  @ValidateNested()
  @Type(() => ContactSectionConfigDto)
  config?: ContactSectionConfigDto;
}

class CtaSectionDto {
  @IsOptional()
  @IsBoolean()
  enabled?: boolean;

  @IsOptional()
  @IsString()
  title?: string;

  @IsOptional()
  @IsString()
  subtitle?: string;

  @IsOptional()
  @ValidateNested()
  @Type(() => CtaSectionConfigDto)
  config?: CtaSectionConfigDto;
}

// ==========================================
// LANDING CONFIG DTO (FIXED!)
// ==========================================

class LandingConfigDto {
  @IsOptional()
  @IsBoolean()
  enabled?: boolean;

  @IsOptional()
  @ValidateNested()
  @Type(() => HeroSectionDto)
  hero?: HeroSectionDto;

  @IsOptional()
  @ValidateNested()
  @Type(() => AboutSectionDto)
  about?: AboutSectionDto;

  @IsOptional()
  @ValidateNested()
  @Type(() => ProductsSectionDto)
  products?: ProductsSectionDto;

  // âœ… FIXED: Use specific TestimonialsSectionDto
  @IsOptional()
  @ValidateNested()
  @Type(() => TestimonialsSectionDto)
  testimonials?: TestimonialsSectionDto;

  @IsOptional()
  @ValidateNested()
  @Type(() => ContactSectionDto)
  contact?: ContactSectionDto;

  @IsOptional()
  @ValidateNested()
  @Type(() => CtaSectionDto)
  cta?: CtaSectionDto;
}

// ==========================================
// MAIN UPDATE TENANT DTO
// ==========================================

export class UpdateTenantDto {
  // ==========================================
  // BASIC INFO
  // ==========================================

  @IsOptional()
  @IsString()
  @MinLength(3, { message: 'Nama toko minimal 3 karakter' })
  @MaxLength(100, { message: 'Nama toko maksimal 100 karakter' })
  name?: string;

  @IsOptional()
  @IsString()
  @MaxLength(500, { message: 'Deskripsi maksimal 500 karakter' })
  description?: string;

  @IsOptional()
  @IsString()
  @Matches(/^62[0-9]{9,13}$/, {
    message: 'Format WhatsApp harus diawali 62 (contoh: 6281234567890)',
  })
  whatsapp?: string;

  @IsOptional()
  @IsString()
  phone?: string;

  @IsOptional()
  @IsString()
  @MaxLength(300, { message: 'Alamat maksimal 300 karakter' })
  address?: string;

  @IsOptional()
  @IsString()
  logo?: string;

  @IsOptional()
  @IsString()
  banner?: string;

  @IsOptional()
  @IsObject()
  theme?: {
    primaryColor?: string;
  };

  @IsOptional()
  @ValidateNested()
  @Type(() => LandingConfigDto)
  landingConfig?: LandingConfigDto;

  // ==========================================
  // SEO FIELDS
  // ==========================================

  @IsOptional()
  @IsString()
  @MaxLength(60, {
    message: 'Meta title maksimal 60 karakter (untuk SEO optimal)',
  })
  metaTitle?: string;

  @IsOptional()
  @IsString()
  @MaxLength(160, {
    message: 'Meta description maksimal 160 karakter (untuk SEO optimal)',
  })
  metaDescription?: string;

  @IsOptional()
  @ValidateNested()
  @Type(() => SocialLinksDto)
  socialLinks?: SocialLinksDto;

  // ==========================================
  // PAYMENT SETTINGS
  // ==========================================

  @IsOptional()
  @IsString()
  @IsIn(['IDR', 'USD', 'SGD', 'MYR'], { message: 'Mata uang tidak valid' })
  currency?: string;

  @IsOptional()
  @IsNumber({}, { message: 'Tax rate harus berupa angka' })
  @Min(0, { message: 'Tax rate tidak boleh negatif' })
  @Max(100, { message: 'Tax rate maksimal 100%' })
  @Type(() => Number)
  taxRate?: number;

  @IsOptional()
  @ValidateNested()
  @Type(() => PaymentMethodsDto)
  paymentMethods?: PaymentMethodsDto;

  // ==========================================
  // SHIPPING SETTINGS
  // ==========================================

  @IsOptional()
  @IsNumber({}, { message: 'Free shipping threshold harus berupa angka' })
  @Min(0, { message: 'Free shipping threshold tidak boleh negatif' })
  @Type(() => Number)
  freeShippingThreshold?: number | null;

  @IsOptional()
  @IsNumber({}, { message: 'Default shipping cost harus berupa angka' })
  @Min(0, { message: 'Default shipping cost tidak boleh negatif' })
  @Type(() => Number)
  defaultShippingCost?: number;

  @IsOptional()
  @ValidateNested()
  @Type(() => ShippingMethodsDto)
  shippingMethods?: ShippingMethodsDto;
}



================================================================================
FILE: src/tenants/dto/change-password.dto.ts
================================================================================

import { IsString, IsNotEmpty, MinLength, Matches } from 'class-validator';

export class ChangePasswordDto {
  @IsString()
  @IsNotEmpty({ message: 'Password lama tidak boleh kosong' })
  currentPassword: string;

  // ==========================================
  // ðŸ”¥ UPDATED: Stronger password policy for change password too
  // ==========================================
  @IsString()
  @IsNotEmpty({ message: 'Password baru tidak boleh kosong' })
  @MinLength(8, { message: 'Password baru minimal 8 karakter' })
  @Matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/, {
    message:
      'Password baru harus mengandung huruf besar, huruf kecil, dan angka',
  })
  newPassword: string;

  @IsString()
  @IsNotEmpty({ message: 'Konfirmasi password tidak boleh kosong' })
  confirmPassword: string;
}



================================================================================
FILE: src/validators/index.ts
================================================================================

export * from './landing-config.validator';



================================================================================
FILE: src/validators/landing-config.validator.ts
================================================================================

// ==========================================
// LANDING CONFIG VALIDATOR
// server/src/validators/landing-config.validator.ts
// ==========================================

import Ajv, { ErrorObject } from 'ajv'; // âœ… FIX: Removed unused JSONSchemaType
import addFormats from 'ajv-formats';

// ==========================================
// TYPE DEFINITIONS
// ==========================================

export interface TestimonialItem {
  id: string;
  name: string;
  role?: string;
  avatar?: string;
  content: string;
  rating?: number;
}

export interface FeatureItem {
  icon?: string;
  title: string;
  description: string;
}

export interface HeroConfig {
  layout?: 'centered' | 'left' | 'right';
  showCta?: boolean;
  ctaText?: string;
  ctaLink?: string;
  backgroundImage?: string;
  overlayOpacity?: number;
}

export interface AboutConfig {
  content?: string;
  showImage?: boolean;
  image?: string;
  features?: FeatureItem[];
}

export interface ProductsConfig {
  displayMode?: 'featured' | 'latest' | 'all';
  limit?: number;
  showViewAll?: boolean;
}

export interface TestimonialsConfig {
  items?: TestimonialItem[];
}

export interface ContactConfig {
  showMap?: boolean;
  showForm?: boolean;
  showSocialMedia?: boolean;
}

export interface CtaConfig {
  buttonText?: string;
  buttonLink?: string;
  style?: 'primary' | 'secondary' | 'outline';
}

export interface LandingSection<T = Record<string, unknown>> {
  enabled?: boolean;
  title?: string;
  subtitle?: string;
  config?: T;
}

export interface LandingConfig {
  [key: string]: unknown; // âœ… FIX: Add index signature for Prisma compatibility
  enabled?: boolean;
  templateId?: string;
  hero?: LandingSection<HeroConfig>;
  about?: LandingSection<AboutConfig>;
  products?: LandingSection<ProductsConfig>;
  testimonials?: LandingSection<TestimonialsConfig>;
  contact?: LandingSection<ContactConfig>;
  cta?: LandingSection<CtaConfig>;
}

export interface ValidationResult {
  valid: boolean;
  data?: LandingConfig;
  errors?: string[];
  warnings?: string[];
}

// ==========================================
// JSON SCHEMA DEFINITIONS
// ==========================================

const testimonialItemSchema = {
  type: 'object' as const,
  required: ['id', 'name', 'content'],
  properties: {
    id: { type: 'string' as const, minLength: 1, maxLength: 100 },
    name: { type: 'string' as const, minLength: 1, maxLength: 100 },
    role: { type: 'string' as const, maxLength: 100 },
    avatar: { type: 'string' as const, maxLength: 500 },
    content: { type: 'string' as const, minLength: 1, maxLength: 1000 },
    rating: { type: 'integer' as const, minimum: 1, maximum: 5 },
  },
  additionalProperties: false,
};

const featureItemSchema = {
  type: 'object' as const,
  required: ['title', 'description'],
  properties: {
    icon: { type: 'string' as const, maxLength: 50 },
    title: { type: 'string' as const, minLength: 1, maxLength: 100 },
    description: { type: 'string' as const, minLength: 1, maxLength: 500 },
  },
  additionalProperties: false,
};

const landingConfigSchema = {
  type: 'object' as const,
  properties: {
    enabled: { type: 'boolean' as const },
    templateId: { type: 'string' as const, maxLength: 50 },

    hero: {
      type: 'object' as const,
      properties: {
        enabled: { type: 'boolean' as const },
        title: { type: 'string' as const, maxLength: 200 },
        subtitle: { type: 'string' as const, maxLength: 500 },
        config: {
          type: 'object' as const,
          properties: {
            layout: {
              type: 'string' as const,
              enum: ['centered', 'left', 'right'],
            },
            showCta: { type: 'boolean' as const },
            ctaText: { type: 'string' as const, maxLength: 50 },
            ctaLink: { type: 'string' as const, maxLength: 200 },
            backgroundImage: { type: 'string' as const, maxLength: 500 },
            overlayOpacity: { type: 'number' as const, minimum: 0, maximum: 1 },
          },
          additionalProperties: false,
        },
      },
      additionalProperties: false,
    },

    about: {
      type: 'object' as const,
      properties: {
        enabled: { type: 'boolean' as const },
        title: { type: 'string' as const, maxLength: 200 },
        subtitle: { type: 'string' as const, maxLength: 500 },
        config: {
          type: 'object' as const,
          properties: {
            content: { type: 'string' as const, maxLength: 2000 },
            showImage: { type: 'boolean' as const },
            image: { type: 'string' as const, maxLength: 500 },
            features: {
              type: 'array' as const,
              maxItems: 10,
              items: featureItemSchema,
            },
          },
          additionalProperties: false,
        },
      },
      additionalProperties: false,
    },

    products: {
      type: 'object' as const,
      properties: {
        enabled: { type: 'boolean' as const },
        title: { type: 'string' as const, maxLength: 200 },
        subtitle: { type: 'string' as const, maxLength: 500 },
        config: {
          type: 'object' as const,
          properties: {
            displayMode: {
              type: 'string' as const,
              enum: ['featured', 'latest', 'all'],
            },
            limit: { type: 'integer' as const, minimum: 1, maximum: 50 },
            showViewAll: { type: 'boolean' as const },
          },
          additionalProperties: false,
        },
      },
      additionalProperties: false,
    },

    testimonials: {
      type: 'object' as const,
      properties: {
        enabled: { type: 'boolean' as const },
        title: { type: 'string' as const, maxLength: 200 },
        subtitle: { type: 'string' as const, maxLength: 500 },
        config: {
          type: 'object' as const,
          properties: {
            items: {
              type: 'array' as const,
              maxItems: 50,
              items: testimonialItemSchema,
            },
          },
          additionalProperties: false,
        },
      },
      additionalProperties: false,
    },

    contact: {
      type: 'object' as const,
      properties: {
        enabled: { type: 'boolean' as const },
        title: { type: 'string' as const, maxLength: 200 },
        subtitle: { type: 'string' as const, maxLength: 500 },
        config: {
          type: 'object' as const,
          properties: {
            showMap: { type: 'boolean' as const },
            showForm: { type: 'boolean' as const },
            showSocialMedia: { type: 'boolean' as const },
          },
          additionalProperties: false,
        },
      },
      additionalProperties: false,
    },

    cta: {
      type: 'object' as const,
      properties: {
        enabled: { type: 'boolean' as const },
        title: { type: 'string' as const, maxLength: 200 },
        subtitle: { type: 'string' as const, maxLength: 500 },
        config: {
          type: 'object' as const,
          properties: {
            buttonText: { type: 'string' as const, maxLength: 50 },
            buttonLink: { type: 'string' as const, maxLength: 200 },
            style: {
              type: 'string' as const,
              enum: ['primary', 'secondary', 'outline'],
            },
          },
          additionalProperties: false,
        },
      },
      additionalProperties: false,
    },
  },
  additionalProperties: false,
};

// ==========================================
// AJV INSTANCE
// ==========================================

const ajv = new Ajv({
  allErrors: true,
  removeAdditional: 'all',
  useDefaults: true,
  coerceTypes: false,
});

addFormats(ajv);

const validateSchema = ajv.compile(landingConfigSchema);

// ==========================================
// SANITIZATION FUNCTIONS
// ==========================================

function flattenNestedArrays<T>(arr: unknown): T[] {
  if (!arr) return [];

  let items = arr;

  while (Array.isArray(items) && items.length > 0 && Array.isArray(items[0])) {
    items = items.flat();
  }

  if (!Array.isArray(items)) return [];

  return items as T[];
}

function deduplicateById<T extends { id: string }>(
  items: T[],
  warningCallback?: (id: string) => void,
): T[] {
  const seen = new Set<string>();
  const unique: T[] = [];

  for (const item of items) {
    if (!item?.id) continue;

    if (seen.has(item.id)) {
      warningCallback?.(item.id);
      continue;
    }

    seen.add(item.id);
    unique.push(item);
  }

  return unique;
}

function ensureTestimonialIds(items: TestimonialItem[]): TestimonialItem[] {
  return items.map((item, index) => ({
    ...item,
    id:
      item.id ||
      `testi_${Date.now()}_${index}_${Math.random().toString(36).substring(2, 7)}`,
  }));
}

function sanitizeTestimonials(
  config: TestimonialsConfig | undefined,
  warningsList: string[], // âœ… FIX: Renamed to warningsList to indicate it's used
): TestimonialsConfig {
  if (!config) return { items: [] };

  let items = config.items;

  items = flattenNestedArrays<TestimonialItem>(items);

  items = items.filter(
    (item): item is TestimonialItem =>
      item &&
      typeof item === 'object' &&
      typeof item.name === 'string' &&
      item.name.trim() !== '' &&
      typeof item.content === 'string' &&
      item.content.trim() !== '',
  );

  items = ensureTestimonialIds(items);

  items = deduplicateById(items, (id) => {
    warningsList.push(`Duplicate testimonial ID removed: ${id}`);
  });

  return { items };
}

function sanitizeFeatures(
  features: FeatureItem[] | undefined,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _warningsList: string[], // âœ… FIX: Prefix with _ to indicate intentionally unused
): FeatureItem[] {
  if (!features) return [];

  let items = flattenNestedArrays<FeatureItem>(features);

  items = items.filter(
    (item): item is FeatureItem =>
      item &&
      typeof item === 'object' &&
      typeof item.title === 'string' &&
      item.title.trim() !== '' &&
      typeof item.description === 'string' &&
      item.description.trim() !== '',
  );

  return items;
}

// ==========================================
// MAIN VALIDATION FUNCTION
// ==========================================

export function validateAndSanitizeLandingConfig(
  data: unknown,
): ValidationResult {
  const warnings: string[] = [];

  if (data === null || data === undefined) {
    return {
      valid: true,
      data: undefined,
      warnings: [],
    };
  }

  if (typeof data !== 'object' || Array.isArray(data)) {
    return {
      valid: false,
      errors: ['landingConfig must be an object'],
    };
  }

  let config: LandingConfig;
  try {
    config = JSON.parse(JSON.stringify(data)) as LandingConfig;
  } catch {
    return {
      valid: false,
      errors: ['landingConfig contains invalid JSON'],
    };
  }

  if (config.testimonials?.config) {
    config.testimonials.config = sanitizeTestimonials(
      config.testimonials.config,
      warnings,
    );
  }

  if (config.about?.config?.features) {
    config.about.config.features = sanitizeFeatures(
      config.about.config.features,
      warnings,
    );
  }

  const valid = validateSchema(config);

  if (!valid) {
    const errors = (validateSchema.errors || []).map((err: ErrorObject) => {
      const path = err.instancePath || '/';
      const message = err.message || 'unknown error';
      return `${path}: ${message}`;
    });

    return {
      valid: false,
      errors,
      warnings,
    };
  }

  if (config.hero?.title) config.hero.title = config.hero.title.trim();
  if (config.hero?.subtitle) config.hero.subtitle = config.hero.subtitle.trim();
  if (config.about?.title) config.about.title = config.about.title.trim();
  if (config.about?.subtitle)
    config.about.subtitle = config.about.subtitle.trim();
  if (config.about?.config?.content) {
    config.about.config.content = config.about.config.content.trim();
  }

  config.enabled = config.enabled ?? false;

  return {
    valid: true,
    data: config,
    warnings: warnings.length > 0 ? warnings : undefined,
  };
}

// ==========================================
// UTILITY EXPORTS
// ==========================================

export function isValidLandingConfig(data: unknown): boolean {
  if (data === null || data === undefined) return true;
  if (typeof data !== 'object' || Array.isArray(data)) return false;

  try {
    const clone = JSON.parse(JSON.stringify(data));
    return validateSchema(clone);
  } catch {
    return false;
  }
}

export function getLandingConfigErrors(data: unknown): string[] {
  if (data === null || data === undefined) return [];
  if (typeof data !== 'object' || Array.isArray(data)) {
    return ['landingConfig must be an object'];
  }

  try {
    const clone = JSON.parse(JSON.stringify(data));
    validateSchema(clone);

    return (validateSchema.errors || []).map((err: ErrorObject) => {
      const path = err.instancePath || '/';
      const message = err.message || 'unknown error';
      return `${path}: ${message}`;
    });
  } catch {
    return ['landingConfig contains invalid JSON'];
  }
}

// ==========================================
// DEFAULT CONFIG GENERATOR
// ==========================================

export function getDefaultLandingConfig(): LandingConfig {
  return {
    enabled: false,
    hero: {
      enabled: false,
      title: '',
      subtitle: '',
      config: {
        layout: 'centered',
        showCta: false,
        ctaText: 'Lihat Produk',
        overlayOpacity: 0.5,
      },
    },
    about: {
      enabled: false,
      title: 'Tentang Kami',
      subtitle: '',
      config: {
        showImage: false,
        features: [],
      },
    },
    products: {
      enabled: false,
      title: 'Produk Kami',
      subtitle: 'Pilihan produk terbaik untuk Anda',
      config: {
        displayMode: 'featured',
        limit: 8,
        showViewAll: false,
      },
    },
    testimonials: {
      enabled: false,
      title: 'Testimoni',
      subtitle: 'Apa kata pelanggan kami',
      config: {
        items: [],
      },
    },
    contact: {
      enabled: false,
      title: 'Hubungi Kami',
      subtitle: '',
      config: {
        showMap: false,
        showForm: false,
        showSocialMedia: false,
      },
    },
    cta: {
      enabled: false,
      title: 'Siap Berbelanja?',
      subtitle: '',
      config: {
        buttonText: 'Mulai Belanja',
        style: 'primary',
      },
    },
  };
}


================================================================================
COLLECTION SUMMARY
================================================================================

âœ… Root Config (9 files)
âœ… Prisma Schema
âœ… src/ Root (5 files)
âœ… Auth Module (6 files)
âœ… Common Module (14 files) - Updated with pipes/
âœ… Customers Module (7 files)
âœ… Database Module (3 files)
âœ… Orders Module (9 files)
âœ… Prisma Module (2 files)
âœ… Products Module (9 files)
âœ… Redis Module (3 files)
âœ… SEO Module (17 files) - NEW! Complete with managers & services
âœ… Sitemap Module (3 files)
âœ… Tenants Module (6 files)
âœ… Validators Module (2 files)

Total Modules: 14
Total Files: ~95 files
Generated: Tue, Jan 13, 2026 10:26:54 PM

